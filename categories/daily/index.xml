<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>daily on Coding and Life</title>
    <link>https://zihuanling.github.io/categories/daily/</link>
    <description>Recent content in daily on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 24 May 2022 14:16:18 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/categories/daily/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Pip Tools生成好看的依赖文件</title>
      <link>https://zihuanling.github.io/posts/pip-tools-generate-dependencies/</link>
      <pubDate>Tue, 24 May 2022 14:16:18 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/pip-tools-generate-dependencies/</guid>
      <description>项目地址： https://pypi.org/project/pip-tools/
pip-tools 是一个命令行工具集合，主要有两个命令： pip-compile，pip-sync，现在主要用的是 pip-compile
在写python项目的时候，我们通常会依赖到其他的包，比如写一个后端的服务，我们可能会依赖到flask/pymysql这些基础的包，随着开发的进行，我们还可能会引入更多的依赖。
这些python依赖包构成了一个完整的服务，开发完成后，我们将这些服务部署到服务器上时，只需要安装好对应的依赖，便可以直接运行服务。
但是，如果我们不将生产环境的依赖固定下来的话，整个服务可能会因为某一次服务更新，其中某个的更新带来的不兼容导致整个服务崩溃。比如pyjwt，在1.7.1版本之前生成的jwt-token是一个bytes类型，我们将其转换成为字符串需要使用到decode()方法。但是在更新到2.0之后，生成的jwt-token是一个字符串类型，如果我们对其再调用decode方法的话，就会发生错误。
这就显现出了固定依赖的重要性了。
通常，固定依赖，我们可以在开发环境使用 pip freeze命令，直接将开发环境的所有版本固定下来到一个 requirements.txt 文件里面，这是懒人做法，当然也很有效。但是文件里面会带有一些系统的依赖版本，比如urllib 之类的，这些我们是不需要再次安装的，所以，如果这些依赖出现在 requirements.txt 文件里面，就会显得不那么干净。
这时，我们可以使用 pip-tools里面的 pip-compile 工具，对依赖进行编译，生成一份漂亮的依赖文件。
直接生成最新依赖  首先，我们将项目中直接依赖的包写到requirements.in文件里面  requirements.in
pymysql flask 使用 pip-compile 自动使用最新依赖版本生成依赖文件  命令： pip-compile, 输出requirements.txt文件：
requirements.txt
# # This file is autogenerated by pip-compile with python 3.8 # To update, run: # # pip-compile # --index-url https://pypi.doubanio.com/simple --trusted-host pypi.doubanio.com  click==8.1.3  # via flask flask==2.1.2  # via -r requirements.</description>
    </item>
    
    <item>
      <title>HTML a标签下载json数据</title>
      <link>https://zihuanling.github.io/posts/html-a-data-download/</link>
      <pubDate>Mon, 09 May 2022 20:52:39 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/html-a-data-download/</guid>
      <description>假如我们有一个json文件：example.json，我们想要将这个文件的连接放到网站上提供下载。
在HTML中这样写：
&amp;lt;a href=&amp;#34;http://lingzihuan.icu/leetcode-submissions.json&amp;#34;&amp;gt;点击下载&amp;lt;/a&amp;gt;  点击下载 当我们点击链接的时候，chrome浏览器会自动打开一个页面，然后将json文件的内容加载进来，但是，当我们想要将文件下载到本地的时候，还得自己右键点击，然后选择”另存为“。
看过 Stack Overflow 上的提示，看到可以给其设定 download属性：
&amp;lt;a href=&amp;#34;http://lingzihuan.icu/leetcode-submissions.json&amp;#34; download&amp;gt;点击下载&amp;lt;/a&amp;gt;  点击下载 需要注意的是，href里面的内容需要是与当前网页同源的url才可使用。</description>
    </item>
    
    <item>
      <title>Jinja2: 判断变量是否为空、存在等</title>
      <link>https://zihuanling.github.io/posts/2022-03-09-jinja-templates-variable-judgement/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-09-jinja-templates-variable-judgement/</guid>
      <description>在 Jinja2 模板中，我们经常需要判断一个变量是否存在，里面的值是否为空等等。
检查变量是否存在，或者是否被定义 {% if variable is defined %}  variable is defined {% else %}  variable is not defined {% endif %} 检查数据的长度是否为空 对于列表类型的变量，我们可能需要知道这个列表是否为空的
{% if variable | length %}  variable is not empty {% else %}  variable is empty {% endif %} 需要注意的是，如果这个变量为非列表类型，模板渲染的时候会报错
检查变量值是否为True {% if variable is sameas true %}  variable is true {% else %}  variable is not true {% endif %} 同样，我们也可以用关键字and来实现多个判断 判断变量存在且不为空（列表型变量） {% if variable is defined and variable | length %}  variable is defined and is not empty {% else %}  variable is not defined or empty {% endif %} 判断变量存在且为true（布尔型变量） {% if variable is defined and is sameas true %}  variable is defined and is true {% else %}  variable is not defined or not true {% endif %} </description>
    </item>
    
    <item>
      <title>让github page支持mermaid语法</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</guid>
      <description>目前，github page 会将 markdown里面的 mermaid 块渲染成为一个 div.language-mermaid 的 html 代码块，但是，mermaid-js仅支持渲染 div.mermaid 的html代码块，因此，我们需要做一点处理。
我们只需要在文章模板的末尾，添加如下转化代码即可：
文件：_layouts/post.html {%- if content contains &amp;#39;mermaid&amp;#39; -%} &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const config = {  startOnLoad:true,  theme: &amp;#39;forest&amp;#39;,  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll(&amp;#39;.language-mermaid&amp;#39;)); &amp;lt;/script&amp;gt; {% endif %} 上述代码手动将 div.language-mermaid 添加到 mermaid引擎的渲染中。
引用 在文章里面指定文章layout，即可引用，并且渲染mermaid！
--- layout: post --- 其他方法 当然也可以在 _config.yml 配置kramdown, 让其可以将 mermaid 块渲染成 div.mermaid 这样的html的代码块，但是实现起来有点复杂。
参考： Issue https://github.</description>
    </item>
    
    <item>
      <title>第一篇GitHub Page博客</title>
      <link>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</guid>
      <description>从 lemonchan.github.io fork了这个博客项目，感觉太棒了，设计很简洁，我需要的功能基本上都有。
感谢！</description>
    </item>
    
  </channel>
</rss>
