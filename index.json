[{"content":"单元测试 单元测试就是对单元进行测试（听起来是一句废话），单元可以是一个函数、一个模块等，我们最小的单元是一个函数。\n以斐波那契数列为例，实现一个测试用例\ntest/main.go\npackage main  // 斐波那契数列 func Fibonacci(n int) int { \tif n \u0026lt;= 0 { \treturn 0 \t} else if n == 1 { \treturn 1 \t} \treturn Fibonacci(n-1) + Fibonacci(n-2) } 我们在 main.go 里面写了一个 Fibonacci函数，用于计算对应的斐波那契值。\n我们接下来写一个测试用例，测试的文件名应该是以 _test.go 结尾的，前面的名称最好是需要测试的文件名称，比如要测试 main.go，则测试文件命名为 main_test.go，而在 测试文件里面，需要一个以 Test开头的函数，后面接需要测试的函数名称，如 TestFibonacci，这个函数接受一个 *Testing.T指针，且不返回任何值\ntest/main_test.go\nfunc TestFibonacci(t *testing.T) { \tresult := map[int]int{ \t1: 1, 2: 1, 3: 2, 4: 3, 5: 5, \t6: 8, 7: 13, 8: 21, \t} \tfor n, expect := range result { \tgot := Fibonacci(n) \tif expect != got{ \tt.Fatalf(\u0026#34;Test Fibonacci failed: expect %d, got %d\u0026#34;, expect, got) \t} else { \tfmt.Printf(\u0026#34;ok, Fibonacci(%d) = %d\\n\u0026#34;, n, got) \t} \t} } 在代码所在目录下，运行测试用例（所有）\ngo test -v . 输出：\n=== RUN TestFibonacci ok, Fibonacci(5) = 5 ok, Fibonacci(6) = 8 ok, Fibonacci(7) = 13 ok, Fibonacci(8) = 21 ok, Fibonacci(1) = 1 ok, Fibonacci(2) = 1 ok, Fibonacci(3) = 2 ok, Fibonacci(4) = 3 --- PASS: TestFibonacci (0.00s) PASS ok let_go/test 1.434s 单元测试覆盖率 通过一个 flag --coverprofile 来获得一个单元测试覆盖率文件：\ngo test -v --coverprofile=test.cover . 输出最后的内容是：\nPASS coverage: 100.0% of statements ok let_go/test 18.222s coverage: 100.0% of statements 可以看到，输出了覆盖率数据，我们的测试用例的覆盖率是 100%。\n当前路径下，生成了一个 test.cover文件，我们可以使用 go tool 从其中得到一个html的覆盖率测试报告：\ngo tool cover -html=test.cover -o=test-cover.html 打开生成的 test-cover.html文件，我们就可以看到对应的覆盖率情况。\n基准测试 基准测试用于评估代码的性能。\n测试文件的命名跟单元测试是一样的，都是 _test.go结尾，不同的是基准测试的函数名是 Benchmark开头，后接被测试函数名，如 BenchmarkFibonacci，同时接收一个 *testing.B指针参数。\nmain_test.go\nfunc BenchmarkFibonacci(b *testing.B) { \tfor i := 0; i \u0026lt; b.N; i++ { \tFibonacci(10) \t} } b.N是框架提供的，表示循环运行次数。\n运行测试用例，同样是使用 go test，不过要加上 -bench参数，后接 . 表示所有，也可以接具体的函数名称。\ngo test -bench=. . # go test -bench=Fibonacci . 输出：\ngoos: windows goarch: amd64 pkg: let_go/test cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkFibonacci-8 3076749 354.4 ns/op PASS ok let_go/test 2.838s BenchmarkFibonacci-8：这里的 -8 表示运行基准测试对应的 GOMAXPROCS 的值。\n3076749：表示一共for循环了 3076749次\n354.4 ns/op：表示每次循环耗时 354.4 ns\n基准测试默认是 1秒，因此上述结果是1秒内运行了3076749次，每次耗时354.4 ns。我们同样可以指定运行时长，使用 -benchtime 参数：\ngo test -bench=. -benchtime=3s . 计时方法 基准测试之前，我们可能需要准备数据，我们的基准测试应该把这部分时间排除在外，这是，我们可以使用 ResetTimer方法：\nfunc BenchmarkFibonacci(b *testing.B) { \tn := 10\t// 前期准备 \tb.ResetTimer() \tfor i := 0; i \u0026lt; b.N; i++ { \tFibonacci(n) \t} } 此外，还有 StartTimer和 StopTimer，可以灵活控制计时时间。\n内存统计 通过 ReportAllocs 方法开启内存统计：\nfunc BenchmarkFibonacci(b *testing.B) { \tn := 10 \tb.ReportAllocs()\t// 报告内存统计 \tb.ResetTimer()\t// 重置计时器 \tfor i := 0; i \u0026lt; b.N; i++ { \tFibonacci(n) \t} } 输出：\nBenchmarkFibonacci-8 3320989 374.9 ns/op 0 B/op 0 allocs/op PASS ok let_go/test 21.393s 发现多了 0 B/op 0 allocs/op 这段输出，前者表示每次分配了多少字节的内存，后者表示每次操作分配内存的次数。\n除了 b.ReportAllocs外，还可以在命令行中使用 -benchmem参数，可以达到同样的效果。\n并发基准测试 主要用以测试 在多个goroutine 下的代码性能，使用 runParallel 方法，传入一个函数作为参数：\nfunc BenchmarkFibonacci(b *testing.B) { \tn := 10 \tb.RunParallel(func(pb *testing.PB){ \tfor pb.Next() { \tFibonacci(n) \t} \t}) } 运行：\ngo test -bench=. . 输出：\nBenchmarkFibonacci-8 13952709 114.2 ns/op 可以看到，并行测试的情况下，函数被运行了 13952709 次。\n优化 可以看到上述基准测试的内存统计中，并没有发生内存申请，也就是说，内存并不是影响函数性能的原因。\n下面我们使用缓存来优化 Fibonacci函数\nmain.go\n// 斐波那契数列 func Fibonacci(n int) int { \tif n \u0026lt;= 0 { \treturn 0 \t} else if n == 1 { \treturn 1 \t} \tv, ok := cache[n] \tif !ok { \tv = Fibonacci(n-1) + Fibonacci(n-2) \tcache[n] = v \t} \treturn v } 再次运行基准测试，输出：\nBenchmarkFibonacci-8 261475790 4.585 ns/op 可以看到，每次循环的时间从 114.2 ns -\u0026gt; 4.585 ns，性能提高了约25倍。\n","permalink":"https://zihuanling.github.io/posts/go-16-test-1/","summary":"单元测试 单元测试就是对单元进行测试（听起来是一句废话），单元可以是一个函数、一个模块等，我们最小的单元是一个函数。\n以斐波那契数列为例，实现一个测试用例\ntest/main.go\npackage main  // 斐波那契数列 func Fibonacci(n int) int { \tif n \u0026lt;= 0 { \treturn 0 \t} else if n == 1 { \treturn 1 \t} \treturn Fibonacci(n-1) + Fibonacci(n-2) } 我们在 main.go 里面写了一个 Fibonacci函数，用于计算对应的斐波那契值。\n我们接下来写一个测试用例，测试的文件名应该是以 _test.go 结尾的，前面的名称最好是需要测试的文件名称，比如要测试 main.go，则测试文件命名为 main_test.go，而在 测试文件里面，需要一个以 Test开头的函数，后面接需要测试的函数名称，如 TestFibonacci，这个函数接受一个 *Testing.T指针，且不返回任何值\ntest/main_test.go\nfunc TestFibonacci(t *testing.T) { \tresult := map[int]int{ \t1: 1, 2: 1, 3: 2, 4: 3, 5: 5, \t6: 8, 7: 13, 8: 21, \t} \tfor n, expect := range result { \tgot := Fibonacci(n) \tif expect !","title":"16.go: 单元测试和基准测试"},{"content":"数组 数组由两部分组成：数组的大小和数组内部的元素类型。\n// 伪代码表示 array {  len  item type } 看以下两个数组的定义：\na1 := [1]string{\u0026#34;mike\u0026#34;} a2 := [2]string{\u0026#34;mike\u0026#34;} 上述定义的两个变量，a1的类型为 [1]string，a2的类型为 [2]string，所以说，数组的大小也属于数组类型的一部分。\n数组的两个限制   **一旦一个数组被声明，它的大小和内部的类型就不能改变，**我们将不能随意向其中追加任意多的元素。\n  另外，当我们使用数组存储大量数据，然后将数组作为函数的参数进行传值时，由于函数之间是值传递的，因此，数组的拷贝将会耗费巨大的内存。\n  slice 切片 我们可以将切片理解为动态的数组。\n切片是对数组的封装，它的底层是一个数组存储了所有的元素，但是它可以动态地添加元素，容量不足时可以自动扩容。\n动态扩容 使用内置的append方法，向切片中追加元素，返回一个新的切片。\n同时，当容量不足的时候，append会自动对切片进行扩容。\nfunc main(){  ss := []string{\u0026#34;mike\u0026#34;} // 定义切片ss  fmt.Printf(\u0026#34;slice before append: %s, length=%d, cap=%d\\n\u0026#34;, ss, len(ss), cap(ss))  ss = append(ss, \u0026#34;lucy\u0026#34;, \u0026#34;john\u0026#34;) // append 追加元素  fmt.Printf(\u0026#34;slice after append: %s, length=%d, cap=%d\\n\u0026#34;, ss, len(ss), cap(ss)) } 输出：\nslice before append: [mike], length=1, cap=1 slice after append: [mike lucy john], length=3, cap=3 数据结构 切片在go语言中是一个数据结构：\ntype SliceHeader struct { \tData uintptr\t// 指向存储切片元素的数组 \tLen int\t// 切片长度 \tCap int\t// 切片容量 } 示例证明：\nfunc main(){  arr := [4]string{\u0026#34;mike\u0026#34;, \u0026#34;lucy\u0026#34;, \u0026#34;john\u0026#34;, \u0026#34;trump\u0026#34;} \ts1 := arr[0:1] \ts2 := arr[:] \ts3 := arr[1:] \ts4 := s2[1:] \ts5 := append(s1, \u0026#34;amy\u0026#34;) \tfmt.Println((*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s1)).Data) \tfmt.Println((*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s2)).Data) \tfmt.Println((*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s3)).Data) \tfmt.Println((*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s4)).Data) \tfmt.Println((*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s5)).Data) \tfmt.Println( \tunsafe.Sizeof(arr), \tunsafe.Sizeof(s1), \tunsafe.Sizeof(s2), \tunsafe.Sizeof(s3), \tunsafe.Sizeof(s4), \tunsafe.Sizeof(s5), \t) } 输出：\n824634801872 824634801872 824634801888 824634801888 824634801872 64 24 24 24 24 24 上述代码中，我们定义了一个数组arr，然后用不同的方法创建了5个数组切片 s1~s5，我们用 unsafe.Pointer 获取到 SliceHeader切片里面指向的Data，可以发现：\n s1 和 s2 Data指向的内存是一样的，因为他们都是从 arr切片下来的，且都是从头部开始切 s2 和 s3 Data指向的内存是不一样的，因为 s3是从arr第2个元素开始切的，它的 Data的初始位置是arr的第二个元素 s4 的Data指向，和s3的是相同的，虽然s4是从s2第1个元素切出来的，但是s2的Data开始地址跟arr一致，因此效果等同于从arr的第二个元素开始切，因此Data指向跟s3一致 s5 是使用append(s1, \u0026quot;amy\u0026quot;)得到，但是返回了新的切片之后，其Data指向的地址仍然和s1是相同的 最后，打印出arr和各个slice的Size，可以看到，数组占用的Size是较大的，而无论slice里面的数据有多少，其都只占用 24字节 大小的内存，符合其 SliceHeader 的定义  高效的原因 一方面，从集合类型的方面考虑，数组、切片和map都是集合类型，他们都可以存放元素，但是数组和切片是连续的内存操作，通过索引就可以快速地找到元素存储的地址，因此取值和赋值要更加高效。\n另一方面，使用切片之所以高效，是因为我们在函数中进行参数传递的时候，传递的只是一份24个字节的SliceHeader数据，实际访问数据时，使用的是同一个底层数组，因此避免了耗费大量内存去拷贝数据，提高了效率。\n需要注意的 使用切片作为函数传值虽然高效，但由于使用的底层数据是相同的，修改切片里面的数据时，其他切片的数据也可能会被修改，一个例子：\n// 打印切片信息 func info(s []string) { \thead := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) \taddr := (*string)(unsafe.Pointer(head.Data)) \tfmt.Printf(\u0026#34;data: %v, address: %v, len: %d, cap: %d \\n\u0026#34;, head.Data, addr, len(s), cap(s)) \tfor i, _ := range s { \tfmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;s[i], s[i]) \t} \tfmt.Println(\u0026#34;======\u0026#34;) }  func main(){  arr := [2]string{\u0026#34;mike\u0026#34;, \u0026#34;lucy\u0026#34;} \ts1 := arr[0:1] \ts2 := append(s1, \u0026#34;amy\u0026#34;) // 往切片s1追加元素，返回新切片给s2 \ts1[0] = \u0026#34;Lisa\u0026#34;\t// 修改切片s1第一个元素为 Lisa \tinfo(s1) \tinfo(s2) \tinfo(arr[:]) } 输出：\ndata: 824634229888, address: 0xc00007c480, len: 1, cap: 3 0xc00007c480 Lisa ====== data: 824634229888, address: 0xc00007c480, len: 2, cap: 3 0xc00007c480 Lisa 0xc00007c490 amy ====== data: 824634229888, address: 0xc00007c480, len: 3, cap: 3 0xc00007c480 Lisa 0xc00007c490 amy 0xc00007c4a0 trump ====== 从上面的输出可以看到，我们从原始数组arr切出了一个切片s1，s1里面只有一个元素，但是，在打印信息的时候，显示它的容量 cap=3，等于原始数组的长度。\n我们往s1里面追加了一个元素 amy，返回一个新的切片s2，然后，将s1的第一个元素改成Lisa，随后的输出结果可以看到，原始数组arr、切片s1、s2的第一个元素都变成了Lisa，而我们往s1追加元素的时候，修改的是原数组的第二个元素， lucy -\u0026gt; amy。且三者的各个数据的地址都是一样的，说明切片和原始数组共用一个底层数组。\n但是，有意思的是，我们使用append往切片中追加元素，当追加的元素超过了当前的slice的容量时，返回的切片指向的就是底层数组就是一块新的内存了。\n我们将上述代码中的 append 语句改成：\ns2 := append(s1, \u0026#34;amy\u0026#34;, \u0026#34;panda\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;java\u0026#34;) // 往切片s1追加元素，返回新切片给s2 输出：\ndata: 824634229888, address: 0xc00007c480, len: 1, cap: 3 0xc00007c480 Lisa ====== data: 824634048608, address: 0xc000050060, len: 5, cap: 6 0xc000050060 mike 0xc000050070 amy 0xc000050080 panda 0xc000050090 python 0xc0000500a0 java ====== data: 824634229888, address: 0xc00007c480, len: 3, cap: 3 0xc00007c480 Lisa 0xc00007c490 lucy 0xc00007c4a0 trump ====== 可以看到有4个变化：\n s2的容量 cap 跟其他两个不同了，自动扩容到了 5 s1和arr的对应元素地址是一样的，说明两者用的底层相同，s2的元素地址跟其他两个不同，说明新申请了一块内存空间来存储s2切片内容 修改s1的第一个元素，没有影响到s2的数据 往s1中追加多个元素，没有影响到原始数组arr的数据  **所以，多个切片使用到同一个底层数组的情况下，应该考虑到数据之间的冲突问题。**go提供一个 copy 内部函数，让我们可以实现切片拷贝，修改拷贝数据，不会影响到原始数据。\n[]byte和string 转换 一般情况下，我们字符串string和[]byte可以这样转换：\nvar s string = \u0026#34;Hello world.\u0026#34; // string -\u0026gt; []byte b := []byte(s) // []byte -\u0026gt; string bs := string(b) slice类型有SliceHeader， 同样的，string类型也有 StringHeader，它的结构体如下：\ntype StringHeader struct {  Data uintptr  Len int } 但是跟 SliceHeader 的区别是，StringHeader少了一个Cap字段用以存储容量。\n回到string 和 []byte 转换的例子，go语言是通过分配内存然后在复制内容的方式，去实现[]byte和string的互相转换的。我们用 SliceHeader、StringHeader看下转换后的 Data指向地址\nfunc main(){ \tvar s string = \u0026#34;Hello world.\u0026#34; \t// string -\u0026gt; []byte \tb := []byte(s) \t// []byte -\u0026gt; string \tbs := string(b) \tfmt.Printf(\u0026#34;addr of s: %v\\n\u0026#34;, (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;s)).Data) \tfmt.Printf(\u0026#34;addr of b: %v\\n\u0026#34;, (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;b)).Data) \tfmt.Printf(\u0026#34;addr of bs: %v\\n\u0026#34;, (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;bs)).Data) } 输出：\naddr of s: 10646786 addr of b: 824634580712 addr of bs: 824634580680 由此可见，直接的 string \u0026lt;-\u0026gt; []byte互转是通过拷贝原始值来实现的。\n转换优化 StringHeader 比 SliceHeader 少了一个Cap字段，我们可以通过 unsafe.Pointer 将 SliceHeader 直接转换成 StringHeader，但是返回来却是行不通的，我们还需要手动补充上一个 Cap字段。\n为了在string 和 []byte 互转的时候节省内存，实现零值拷贝，我们在转换的时候，使用对应的Header结构体 + unsafe.Pointer进行转换。\n将上述例子改变如下：\nfunc main(){ \tvar s string = \u0026#34;Hello world.\u0026#34; \t// string -\u0026gt; []byte \tsliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) \tsliceHeader.Cap = sliceHeader.Len \tb := *(*[]byte)(unsafe.Pointer(sliceHeader)) \t// []byte -\u0026gt; string \tstringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;b)) \tbs := *(*string)(unsafe.Pointer(stringHeader)) \t\tfmt.Printf(\u0026#34;%s, addr of s: %v\\n\u0026#34;, s, (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;s)).Data) \tfmt.Printf(\u0026#34;%s, addr of b: %v\\n\u0026#34;, b, (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;b)).Data) \tfmt.Printf(\u0026#34;%s, addr of bs: %v\\n\u0026#34;, bs, (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;bs)).Data) } 输出：\nHello world., addr of s: 9860354 Hello world., addr of b: 9860354 Hello world., addr of bs: 9860354 可以看到，修改之后，对应的Header中Data指向的是同一个地址。\n需要注意的是，通过 unsafe.Pointer将stirng转换为 []byte的时候，不可以通过索引对 []byte修改，否则会导致程序崩溃，因为go语言中，string内存是只读的。\ngo语言标准库中， strings.Builder 也使用了零值拷贝提升新能：\n// String returns the accumulated string. func (b *Builder) String() string {  return *(*string)(unsafe.Pointer(\u0026amp;b.buf)) } ","permalink":"https://zihuanling.github.io/posts/go-15-depth-slice-header/","summary":"数组 数组由两部分组成：数组的大小和数组内部的元素类型。\n// 伪代码表示 array {  len  item type } 看以下两个数组的定义：\na1 := [1]string{\u0026#34;mike\u0026#34;} a2 := [2]string{\u0026#34;mike\u0026#34;} 上述定义的两个变量，a1的类型为 [1]string，a2的类型为 [2]string，所以说，数组的大小也属于数组类型的一部分。\n数组的两个限制   **一旦一个数组被声明，它的大小和内部的类型就不能改变，**我们将不能随意向其中追加任意多的元素。\n  另外，当我们使用数组存储大量数据，然后将数组作为函数的参数进行传值时，由于函数之间是值传递的，因此，数组的拷贝将会耗费巨大的内存。\n  slice 切片 我们可以将切片理解为动态的数组。\n切片是对数组的封装，它的底层是一个数组存储了所有的元素，但是它可以动态地添加元素，容量不足时可以自动扩容。\n动态扩容 使用内置的append方法，向切片中追加元素，返回一个新的切片。\n同时，当容量不足的时候，append会自动对切片进行扩容。\nfunc main(){  ss := []string{\u0026#34;mike\u0026#34;} // 定义切片ss  fmt.Printf(\u0026#34;slice before append: %s, length=%d, cap=%d\\n\u0026#34;, ss, len(ss), cap(ss))  ss = append(ss, \u0026#34;lucy\u0026#34;, \u0026#34;john\u0026#34;) // append 追加元素  fmt.Printf(\u0026#34;slice after append: %s, length=%d, cap=%d\\n\u0026#34;, ss, len(ss), cap(ss)) } 输出：","title":"15.go深入：SliceHeader，高效的slice"},{"content":"unsafe是不安全的，可以绕过go的安全检查机制，直接对内存进行读写，非必要不使用。\n指针类型转换 go是一门强类型的静态语言，意味着一旦定义了，类型就不能改变，且类型检查在运行前已经完成。\n出于安全考虑，go不允许两个指针类型进行转换，比如 *int 不能转换成 *float。\ni := 10 ip := \u0026amp;i var fp *float64 = (*float64)(ip)\t// 尝试将 *int 转换成 *float64 在编译的时候，会报错： cannot convert ip (type * int) to type * float64，提示不可转换\nunsafe.Pointer unsafe.Pointer表示任意类型的指针，上述例子中，我们使用 unsafe.Pointer进行中转，实现指针类型转换\ni := 10 ip := \u0026amp;i var fp *float64 = (*float64)(unsafe.Pointer(ip))\t// 尝试将 *int 转换成 *float64 *fp = *fp * 3 fmt.Println(i,*fp, ip, fp) 输出：\n30 1.5e-322 0xc0000aa058 0xc0000aa058 可以看到，通过转化后的指针修改指向内存的值，原始值i也变成了30，ip和fp指向的是同一块内存地址。需要注意的是，试图通过 *fp 打印出原来内存的数据时，却出现了一个异常值，说明指针可以通过 unsafe.Pointer 进行转化，但转化后的指针不一定可以访问到原始内存的值。\nunsafe.Pointer源码定义：\n// ArbitraryType is here for the purposes of documentation // only and is not actually part of the unsafe package. // It represents the type of an arbitrary Go expression. type ArbitraryType int type Pointer *ArbitraryType ArbitraryType可以表示任意类型，在源码中只是文档需要。unsafe.Pointer是 *ArbitraryType，表示通用型指针，可以表示任何内存地址。\nuintptr 指针类型 因为 unsafe.Pointer 不能进行运行，如 + 运行操作，因此有 uintptr，它足够大，可以表示任何指针，也可以对指针进行偏移计算，访问特定的内存，实现真正的内存级操作。\nuintptr定义：\n// uintptr is an integer type that is large enough // to hold the bit pattern of any pointer. type uintptr uintptr 使用 uintptr修改结构体内部字段例子：\nfunc main() { \tp := new(person)  // p.Name是第一个字段，因此不需要偏移 \tpName := (*string)(unsafe.Pointer(p)) \t*pName = \u0026#34;Mike\u0026#34;  // p.Age不是第一个字段，需要使用 uintptr 和 unsafe.Offsetof 进行偏移计算 \tu := uintptr(unsafe.Pointer(p)) + unsafe.Offsetof(p.Age)  // 计算过偏移的 uintptr 需要通过 unsafe.Pointer 再次转化成 *int（或者*uint） \tpAge := (*int)(unsafe.Pointer(u)) \tfmt.Println(\u0026#34;address of uintptr of age is : \u0026#34;, u, pAge, \u0026amp;p.Age) \t*pAge = 20 \tfmt.Println(*p) } 输出：\naddress of uintptr of age is : 824633737352 0xc000004088 0xc000004088 {Mike 20} 可以看到，计算偏移后， PAge 和 p.Age 指向的地址是一样的，对应的值也修改成功了。\n上述操作步骤：\n  先使用 new 函数声明一个 *person 类型的指针变量 p。 然后把 *person 类型的指针变量 p 通过 unsafe.Pointer，转换为 *string 类型的指针变量 pName。 因为 person 这个结构体的第一个字段就是 string 类型的 Name，所以 pName 这个指针就指向 Name 字段（偏移为 0），对 pName 进行修改其实就是修改字段 Name 的值。 因为 Age 字段不是 person 的第一个字段，要修改它必须要进行指针偏移运算。所以需要先把指针变量 p 通过 unsafe.Pointer 转换为 uintptr，这样才能进行地址运算。既然要进行指针偏移，那么要偏移多少呢？这个偏移量可以通过函数 unsafe.Offsetof 计算出来，该函数返回的是一个 uintptr 类型的偏移量，有了这个偏移量就可以通过 + 号运算符获得正确的 Age 字段的内存地址了，也就是通过 unsafe.Pointer 转换后的 *int 类型的指针变量 pAge。 然后需要注意的是，如果要进行指针运算，要先通过 unsafe.Pointer 转换为 uintptr 类型的指针。指针运算完毕后，还要通过 unsafe.Pointer 转换为真实的指针类型（比如示例中的 *int 类型），这样可以对这块内存进行赋值或取值操作。 有了指向字段 Age 的指针变量 pAge，就可以对其进行赋值操作，修改字段 Age 的值了。   上述代码效果等价于：\nfunc main() {  p := new(person)  p.Name = \u0026#34;Mike\u0026#34;  p.Age = 20 } 指针转换规则 flowchart LR *T \u0026lt;--转换--\u0026gt; unsafe.Pointer \u0026lt;--转换--\u0026gt; uintptr unsafe.Pointer主要用于指针类型的转换，uintptr主要用于偏移量定位不同的内存位置。\n总结 unsafe包里的功能虽然不安全，但很实用，如指针运算、类型转换等，有助于我们提高性能。\n","permalink":"https://zihuanling.github.io/posts/go-14-depth-unsafe/","summary":"unsafe是不安全的，可以绕过go的安全检查机制，直接对内存进行读写，非必要不使用。\n指针类型转换 go是一门强类型的静态语言，意味着一旦定义了，类型就不能改变，且类型检查在运行前已经完成。\n出于安全考虑，go不允许两个指针类型进行转换，比如 *int 不能转换成 *float。\ni := 10 ip := \u0026amp;i var fp *float64 = (*float64)(ip)\t// 尝试将 *int 转换成 *float64 在编译的时候，会报错： cannot convert ip (type * int) to type * float64，提示不可转换\nunsafe.Pointer unsafe.Pointer表示任意类型的指针，上述例子中，我们使用 unsafe.Pointer进行中转，实现指针类型转换\ni := 10 ip := \u0026amp;i var fp *float64 = (*float64)(unsafe.Pointer(ip))\t// 尝试将 *int 转换成 *float64 *fp = *fp * 3 fmt.Println(i,*fp, ip, fp) 输出：\n30 1.5e-322 0xc0000aa058 0xc0000aa058 可以看到，通过转化后的指针修改指向内存的值，原始值i也变成了30，ip和fp指向的是同一块内存地址。需要注意的是，试图通过 *fp 打印出原来内存的数据时，却出现了一个异常值，说明指针可以通过 unsafe.Pointer 进行转化，但转化后的指针不一定可以访问到原始内存的值。","title":"14.go深入：非类型安全unsafe"},{"content":"啥是反射 go语言中，反射为我们提供了一种可以在运行时操作任意类型对象的能力，比如，查看一个接口变量的具体类型、看一个结构体有多少字段、修改某个字段的值等。\n比如 fmt.Println：\nfunc Println(a ...interface{}) (n int, err error) {  return Fprintln(os.Stdout, a...) } 函数定义中有一个可变参数 a ...interface{}，我们在调用的时候，可以传1个到多个参数进去。\nreflect.Value 和 reflect.Type go语言的反射定义中，任何接口都有两个部分组成：接口的具体类型，以及具体类型对应的值。如 var i in = 3，由于 interface{}可以表示任何类型，因此i可以转化为 interface{}，将其当做一个接口，此时它在go反射中就表示成 \u0026lt;Value, Type\u0026gt;，其中Value为3，Type为int。\ngo反射中，标准库为我们提供了两种类型 reflect.Value和 reflect.Type分别表示变量的值和类型，并且可以用函数 reflect.ValueOf和 reflect.TypeOf分别获取任意对象 Value和Type。\nfunc main(){  var i int = 3  iv := reflect.ValueOf(i)  it := reflect.TypeOf(i)  fmt.Println(iv, it) } reflect.Value 结构体定义 reflect.Value 可以通过 reflect.ValueOf获得，其结构体定义如下\ntype Value struct {  typ *rtype  ptr unsafe.Pointer  flag } 其里面的变量都是私有的，意味着我们只能使用它的方法，它的常用方法有：\n//针对具体类型的系列方法 //以下是用于获取对应的值 Bool Bytes Complex Float Int String Uint CanSet //是否可以修改对应的值 // 以下是用于修改对应的值 Set SetBool SetBytes SetComplex SetFloat SetInt SetString Elem //获取指针指向的值，一般用于修改对应的值 //以下Field系列方法用于获取struct类型中的字段 Field FieldByIndex FieldByName FieldByNameFunc Interface //获取对应的原始类型 IsNil //值是否为nil IsZero //值是否是零值 Kind //获取对应的类型类别，比如Array、Slice、Map等 //获取对应的方法 Method MethodByName NumField //获取struct类型中字段的数量 NumMethod//类型上方法集的数量 Type//获取对应的reflect.Type 可以总结为3类：\n  用户获取和修改对应的值\n  和struct类型的字段有关\n  和类型上的方法集有关，用于获取对应的方法\n  获取原始类型 我们使用 reflect.ValueOf 将任意类型的对象转为 reflect.Value，也可以通过 reflect.Interface进行逆转换\nfunc main(){  var i int = 3  // int to reflect.Value  iv := reflect.ValueOf(i)  // reflect.Value to int  i1 := iv.Interface().(int)  fmt.Println(iv, i1) } 修改对应的值 已经定义的变量可以通过反射，在运行时修改，如下所示：\nfunc main() {  i := 3  ipv := reflect.ValueOf(\u0026amp;i)  ipv.Elem().SetInt(4)  fmt.Println(i) } 需要注意的是， reflect.ValueOf 返回的是一个值的拷贝，因此，我们想要修改原始值，就需要传入指针变量。\n因为传入的是指针变量，所以需要调用 Elem()方法，找到这个指针指向的值，然后才能调用 Set... 方法进行修改。\n所以，使用运行时修改变量值的关键点在于：\n传递指针（可寻址），通过 Elem方法获取指向的值，才可以保证值可以被修改。reflect.Value为我们提供了 CanSet方法，判断是否可修改该变量。\n修改struct结构体中的值，也是同理：\n 传递strcut结构体指针，获取 reflect.ValueOf 通过 Elem方法获取指针指向的值 通过 Field方法获取需要修改的字段 通过 Set系列方法，修改成对应的值  type person struct { \tName string \tAge uint }  func main(){  p := person{Name: \u0026#34;mike\u0026#34;, Age: 10} \tfmt.Println(\u0026#34;Original person is : \u0026#34;, p) \tppv := reflect.ValueOf(\u0026amp;p) \tppv.Elem().FieldByName(\u0026#34;Age\u0026#34;).SetUint(20)\t// set age to 20  // ppv.Elem().Field(1).SetUint(20)\t// 也可 \tfmt.Println(\u0026#34;person changed: \u0026#34;, p) } 输出：\nOriginal person is : {mike 10} person changed: {mike 20} 小总结，通过反射修改一个值的规则：\n 可被寻址，即需要向 reflect.ValueOf 传递一个指针作为参数 如果想修改struct结构体的字段值，则对应的字段必须是可导出的，即该字段的首字母是大写的 需要使用 Elem 方法获得指针指向的值，才能通过 Set 系列方法进行修改  获取对应的底层类型 可以使用 Kind 方法获取对应的底层类型：\nfunc main(){  p := person{\u0026#34;Mike\u0026#34;, 20}  ppv := reflect.ValueOf(\u0026amp;p)  pv := reflect.ValueOf(p)  fmt.Println(ppv.Kind(), pv.Kind())\t// ptr, struct } Kind返回的值可以为：\ntype Kind uint const (  Invalid Kind = iota  Bool  Int  Int8  Int16  Int32  Int64  Uint  Uint8  Uint16  Uint32  Uint64  Uintptr  Float32  Float64  Complex64  Complex128  Array  Chan  Func  Interface  Map  Ptr  Slice  String  Struct  UnsafePointer ) reflect.Type 我们使用 reflect.TypeOf 获取一个 reflect.Type。\nreflect.Value 用于于值有关的操作中，而如果是和变量类型本身有关的操作，则最好使用reflectType，如：获取结构体对应的字段名称或方法。\n接口定义 reflect.Value是一个结构体，而 reflect.Type是一个接口，大部分常用方法同 reflect.Value是相同的，如下：\ntype Type interface {  Implements(u Type) bool  AssignableTo(u Type) bool  ConvertibleTo(u Type) bool  Comparable() bool   // 同 reflect.Value功能相同  Kind() Kind  Method(int) Method  MethodByName(string) (Method, bool)  NumMethod() int  Elem() Type  Field(i int) StructField  FieldByIndex(index []int) StructField  FieldByName(name string) (StructField, bool)  FieldByNameFunc(match func(string) bool) (StructField, bool)  NumField() int } 特有的方法：\n Implements：用于判断是否实现了该接口 AssignableTo：用于判断是否可以赋值给类型u，即使用=进行赋值 ConvertibleTo：用于判断是否可以转换为类型u Comparable：用于判断该类型是否可比较，使用关系运算符进行比较  遍历结构体的字段和方法 // 实现String方法 func (p person) String() string { \treturn fmt.Sprintf(\u0026#34;This person name is %s, age = %d\u0026#34;, p.Name, p.Age) }  func main(){  p := person{\u0026#34;Mike\u0026#34;, 20}  pt := reflect.TypeOf(p)  // 遍历字段  for i := 0; i \u0026lt; pt.NumField(); i++ {  fmt.Printf(\u0026#34;Field %d: %s\\n\u0026#34;, i+1, pt.Field(i).Name) \t} \t// 遍历方法 \tfor i := 0; i \u0026lt; pt.NumMethod(); i++ { \tfmt.Printf(\u0026#34;Method %d: %s\\n\u0026#34;, i+1, pt.Method(i).Name) \t} } 输出：\nField 1: Name Field 2: Age Method 1: String 是否实现某接口 下面检查person是否实现 fmt.Stringer 和 io.Writer 接口：\nfunc main(){  p := person{\u0026#34;Mike\u0026#34;, 20}  pt := reflect.TypeOf(p)  stringerType := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()  writerType := reflect.TypeOf((*io.Writer)(nil)).Elem()  fmt.Println(\u0026#34;person implement stringer: \u0026#34;, pt.Implements(stringerType))  fmt.Println(\u0026#34;person implement writer: \u0026#34;, pt.Implements(writerType)) } 输出：\nperson implement stringer: true person implement writer: false 由于 fmt.Stringer 是一个接口，而传入 reflect.TypeOf 里面的必须是一个值，因此需要转化一下，传入一个空接口指针 (*fmt.Stringer)(nil)，然后取其对应的 Elem 进行判断。\n这样的做法很少，我们一般使用断言进行判断，而不是反射，以下写法更简单：\nfunc main(){  p := person{\u0026#34;Mike\u0026#34;, 20}  pt := reflect.TypeOf(p)  _, ok := pt.(fmt.Stringer)  fmt.Println(\u0026#34;Stringer implemented by person: \u0026#34;, ok) } 通过反射调用方法 type person struct { \tName string `json:\u0026#34;name\u0026#34;` \tAge uint\t`json:\u0026#34;age\u0026#34;` }  func (p person) Greet(who string) { \tfmt.Printf(\u0026#34;Hello! %s is greeting to %s.\\n\u0026#34;, who, p.Name) }  func main() {  p := person{Name: \u0026#34;Mike\u0026#34;, Age: 10}  pv := reflect.ValueOf(p)  method := pv.MethodByName(\u0026#34;Greet\u0026#34;) \t// call method \targs := []reflect.Value{ \treflect.ValueOf(\u0026#34;Amy\u0026#34;), \t}  // 相当于 p.Greet(\u0026#34;Amy\u0026#34;) \tmethod.Call(args)  /* // 同样可以这样写 pt := reflect.TypeOf(p) method, ok := pt.MethodByName(\u0026#34;Greet\u0026#34;) if !ok { fmt.Println(\u0026#34;Method [Greet] not exist\u0026#34;) } else { // call method args := []reflect.Value{ reflect.ValueOf(p), reflect.ValueOf(\u0026#34;Amy\u0026#34;), } // 相当于 Greet(p, \u0026#34;Amy\u0026#34;) method.Func.Call(args) } */ } 输出：\nHello! Amy is greeting to Mike. 字符串和结构体互换 字符串和结构体互转，最多是Json和Struct互相转换，这样的转换相当于python里面将字典序列化成为json字符串或者反序列化。\nJson和Struct互转 go语言提供了一个json包，可以让我们实现json字符串和struct结构体的互转：\nfunc main() {  p := person{Name: \u0026#34;Mike\u0026#34;, Age: 10}  // struct 转换成字符串  pJson, err := json.Marshal(p)  if err == nil {  fmt.Printf(\u0026#34;pJson string : %s\\n\u0026#34;, pJson) \t} \t// Json 字符串转化为struct结构体 \tjsonString := \u0026#34;{\\\u0026#34;Name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;, \\\u0026#34;Age\\\u0026#34;: 20}\u0026#34; \tif err := json.Unmarshal([]byte(jsonString), \u0026amp;p); err == nil { \tfmt.Printf(\u0026#34;Unmarshaled struct: %s\\n\u0026#34;, p) \t} else { \tfmt.Printf(\u0026#34;Error unmarshal: %e\\n\u0026#34;, err) \t} } 输出：\npJson string : {\u0026#34;Name\u0026#34;:\u0026#34;Mike\u0026#34;,\u0026#34;Age\u0026#34;:10} Unmarshaled struct: This person name is Jack, age = 20  通过 json.Marshal 将struct转化成 字符串（返回的是 []byte） 通过 json.Unmarshal 将json字符串（[]byte）转化成 strcut结构体  需要注意的是，如果 person 的定义中，含有私有成员变量（小写开头），那么在json序列化和反序列化的过程中，将不会解析/赋值该字段。\nStruct Tag Struct Tag是struct结构体字段的标签，用其辅助完成一些额外的操作，如果 json和struct 互转，使用tag让json化的字段变成小写：\ntype person struct { \tName string `json:\u0026#34;name\u0026#34;` \tAge uint\t`json:\u0026#34;age\u0026#34;` }  func main() {  p := person{Name: \u0026#34;Mike\u0026#34;, Age: 10}  // struct 转换成字符串  pJson, err := json.Marshal(p)  if err == nil {  fmt.Printf(\u0026#34;pJson string : %s\\n\u0026#34;, pJson) \t} \t// Json 字符串转化为struct结构体  jsonString := \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;Jack\\\u0026#34;, \\\u0026#34;age\\\u0026#34;: 20}\u0026#34; \tif err := json.Unmarshal([]byte(jsonString), \u0026amp;p); err == nil { \tfmt.Printf(\u0026#34;Unmarshaled struct: %s\\n\u0026#34;, p) \t} } 输出：\npJson string : {\u0026#34;name\u0026#34;:\u0026#34;Mike\u0026#34;,\u0026#34;age\u0026#34;:10} Unmarshaled struct: This person name is Jack, age = 20 需要注意的是，json.Unmarshal传入的字符串，如果存在 \u0026quot;{\\\u0026quot;age\\\u0026quot;: 10, \\\u0026quot;Age\\\u0026quot;: 20}\u0026quot; 两个字段，那么在反序列化之后，得到的结构体对应的值是最后一个，即20。\n我们通过反射获取结构体的tag，通过 Field方法返回一个StructField，然后取Tag.Get 获取对应的tag\nfunc main() {  p := person{Name: \u0026#34;Mike\u0026#34;, Age: 10}  pt := reflect.TypeOf(p)  for i := 0; i \u0026lt; pt.NumField(); i++ {  f := pt.Field(i)  fmt.Println(f.Tag.Get(\u0026#34;json\u0026#34;)) \t} } 同一个结构体可以定义多个tag：\ntype person struct {  Name string `json:\u0026#34;name\u0026#34; bson:\u0026#34;b_name\u0026#34;`  Age uint `json:\u0026#34;age\u0026#34; bson:\u0026#34;b_age\u0026#34;` } 实现Struct转Json func StructToJson(i interface{}) string { \tbuilder := strings.Builder{} \tbuilder.WriteString(\u0026#34;{\u0026#34;) \tiv := reflect.ValueOf(i) \tit := reflect.TypeOf(i) \tnumFields := it.NumField() \tfor i := 0; i \u0026lt; numFields; i++ { \tf := it.Field(i) \tjTag := f.Tag.Get(\u0026#34;json\u0026#34;) \tbuilder.WriteString(\u0026#34;\\\u0026#34;\u0026#34; + jTag + \u0026#34;\\\u0026#34;:\u0026#34;) \tbuilder.WriteString(fmt.Sprintf(\u0026#34;\\\u0026#34;%v\\\u0026#34;\u0026#34;, iv.Field(i))) \tif i \u0026lt; numFields - 1 { \tbuilder.WriteString(\u0026#34;,\u0026#34;) \t} \t} \tbuilder.WriteString(\u0026#34;}\u0026#34;) \treturn fmt.Sprintf(\u0026#34;%s\u0026#34;, builder.String()) }  func main() {  p := person{Name: \u0026#34;Mike\u0026#34;, Age: 10}  s := StructToJson(p)  fmt.Println(s) } 输出：\n{\u0026#34;name\u0026#34;:Mike,\u0026#34;age\u0026#34;:10} 反射定律 反射是计算机语言中程序检视自身结构的一种方法，灵活、强大，可以绕过编译器的很多静态检查，过多使用会造成混乱。\n 任何接口值 interface{}都可以反射出反射对象，即 reflect.Value和reflect.Type，通过函数 reflect.ValueOf和reflect.TypeOf获得 反射对象也可以还原为 interface{}变量，即定律1 的可逆性，通过 reflect.Value的 Interface方法获得 要修改反射的对象，该值必须可设置（传入指针）  总结 在反射中，获取变量的值、修改变量的值等，优先使用 reflect.Value；获取结构体内的字段、类型拥有的方法集等，优先使用 reflect.Type\n","permalink":"https://zihuanling.github.io/posts/go-13-depth-reflect/","summary":"啥是反射 go语言中，反射为我们提供了一种可以在运行时操作任意类型对象的能力，比如，查看一个接口变量的具体类型、看一个结构体有多少字段、修改某个字段的值等。\n比如 fmt.Println：\nfunc Println(a ...interface{}) (n int, err error) {  return Fprintln(os.Stdout, a...) } 函数定义中有一个可变参数 a ...interface{}，我们在调用的时候，可以传1个到多个参数进去。\nreflect.Value 和 reflect.Type go语言的反射定义中，任何接口都有两个部分组成：接口的具体类型，以及具体类型对应的值。如 var i in = 3，由于 interface{}可以表示任何类型，因此i可以转化为 interface{}，将其当做一个接口，此时它在go反射中就表示成 \u0026lt;Value, Type\u0026gt;，其中Value为3，Type为int。\ngo反射中，标准库为我们提供了两种类型 reflect.Value和 reflect.Type分别表示变量的值和类型，并且可以用函数 reflect.ValueOf和 reflect.TypeOf分别获取任意对象 Value和Type。\nfunc main(){  var i int = 3  iv := reflect.ValueOf(i)  it := reflect.TypeOf(i)  fmt.Println(iv, it) } reflect.Value 结构体定义 reflect.Value 可以通过 reflect.ValueOf获得，其结构体定义如下\ntype Value struct {  typ *rtype  ptr unsafe.","title":"13.go深入：reflect 运行时反射"},{"content":"Go语言程序所管理的虚拟内存空间会被分为两部分：堆内存和栈内存。栈内存主要由Go语言来管理，开发者无法干涉太多，堆内存则有开发者进行分配。\n变量 一个数据类型，在声明之后，会被赋值给一个变量，变量存储了程序所需的数据。\n变量的声明 单纯的声明变量，可以使用var关键字，如：\nvar s string\t// 声明一个[字符串]变量，初始值为零值\u0026#34;\u0026#34; var sp *string\t// 声明一个[字符串指针]变量，初始值为 nil 变量的初始化 有3种方法\n 声明的时候直接初始化： var name string = \u0026quot;mike\u0026quot; 声明之后再进行赋值初始化： name = \u0026quot;mike\u0026quot;,此前 name 变量已经声明 直接使用 := 进行初始化： name := \u0026quot;mike\u0026quot;  值变量和指针变量初始化的区别 我们使用值初始化的时候，可以简单的这样写：\nvar name string name = \u0026#34;mike\u0026#34; 但是，当我们使用指针初始化的时候：\nvar nameP *string // 声明一个字符串指针 *nameP = \u0026#34;mike\u0026#34;\t// 给nameP指向的地址赋值初始化 这时候，由于 nameP 指向的是一个空地址 nil，我们对这个空地址进行赋值初始化的时候，会报以下错误：\npanic: runtime error: invalid memory address or nil pointer dereference 显而易见，我们无法对一个空地址赋值。\n因此，**如果要对一个变量赋值，这个变量必须有对应的分配好的内存，这样才可以对这块内存操作，完成赋值的目的。**不止是赋值操作，针对指针变量，如果没有分配内存，对其进行取值时一样会报 nil异常，因为没有可以操作的内存。\nnew函数 声明指针变量的时候，是默认没有分配内存的，因此，我们可以使用 new 函数来进行内存的分配：\nvar nameP *string nameP = new(string) // 分配一块string类型的内存 *nameP := \u0026#34;mike\u0026#34; fmt.Println(*nameP) 这样，我们的nameP变量指向的就不是一个 nil 空地址了，而是指向了一块具体的字符串的内存。因此可以对其进行赋值操作。\nnew函数源码 // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type 所以 new就是根据传入的类型，申请一块内存，然后返回指向这块内存的指针，该块内存初始化的数据就是该类型的零值。\nmake函数 make函数是map、slice、chan的工厂函数，可以同时用于三种类型的初始化。\n总结 new函数只用于分配内存，并且把内存清零，也就是返回一个指向对应类型的零值的指针。new函数一般用于需要显式地返回指针的情况，不常用。\nmake函数只用于slice、chan、map三种内置类型的创建和初始化，因为这三种类型的结构比较复杂，如 slice 要提前初始化好内部元素的类型，slice的长度和容量等，这样才能更好地使用它们。\n","permalink":"https://zihuanling.github.io/posts/go-12-depth-new-and-make/","summary":"Go语言程序所管理的虚拟内存空间会被分为两部分：堆内存和栈内存。栈内存主要由Go语言来管理，开发者无法干涉太多，堆内存则有开发者进行分配。\n变量 一个数据类型，在声明之后，会被赋值给一个变量，变量存储了程序所需的数据。\n变量的声明 单纯的声明变量，可以使用var关键字，如：\nvar s string\t// 声明一个[字符串]变量，初始值为零值\u0026#34;\u0026#34; var sp *string\t// 声明一个[字符串指针]变量，初始值为 nil 变量的初始化 有3种方法\n 声明的时候直接初始化： var name string = \u0026quot;mike\u0026quot; 声明之后再进行赋值初始化： name = \u0026quot;mike\u0026quot;,此前 name 变量已经声明 直接使用 := 进行初始化： name := \u0026quot;mike\u0026quot;  值变量和指针变量初始化的区别 我们使用值初始化的时候，可以简单的这样写：\nvar name string name = \u0026#34;mike\u0026#34; 但是，当我们使用指针初始化的时候：\nvar nameP *string // 声明一个字符串指针 *nameP = \u0026#34;mike\u0026#34;\t// 给nameP指向的地址赋值初始化 这时候，由于 nameP 指向的是一个空地址 nil，我们对这个空地址进行赋值初始化的时候，会报以下错误：\npanic: runtime error: invalid memory address or nil pointer dereference 显而易见，我们无法对一个空地址赋值。","title":"12.go深入：new、make和内存分配"},{"content":"值类型 假设我们有一个这样的结构体：\ntype person struct {  name string  age uint } 然后我们试图定义一个函数，修改这个结构体实例的值：\nfunc modify(argP person){  argP.name = \u0026#34;Nobody\u0026#34;  argP.age = 10 }  // 我们实际运行一下这个函数 func main(){  p := person{name: \u0026#34;mike\u0026#34;, age: 19}  fmt.Println(p)  modify(p)  fmt.Println(p) } 上述的例子中，我们期望在经过了modify函数修改后，打印出来的结果是 {Nobody, 10}，然而实际上，输出的仍然是初始化的值： {mike, 19}\n为啥会这样呢，因为上面定义的变量 p 是值类型，而通过modify函数传入的变量值argP只是原始值变量p的一份值拷贝，而不是原来的数据本身。\n其实，我们只要在modify函数内部和外部打印出变量p和argP的地址，就可以发现他们的不同之处。\nfunc modify(argP person){  fmt.Printf(\u0026#34;address of arg p: %p\\n\u0026#34;, \u0026amp;argP)  // ... }  func main(){  // ...  fmt.Printf(\u0026#34;address of p: %p\\n\u0026#34;, \u0026amp;p)  modify(p)  // ... } 输出为：\naddress of p: 0xc0002905a0 address of arg p: 0xc0000d01b0 可以看到，在函数内部和外部，变量的地址是不一样的。\n实际上，在go语言中，函数的传参都是值传递，也就是原来数据的一份拷贝，而不是数据本身。以上述的modify函数来说，参数argP就是原始变量p的一份值拷贝。除了struct之外，还有浮点型、整形、字符串、布尔、数组等，这些都是值类型\n指针类型 回到最初的期望，我们想要修改 person 的值，只需要修改modify函数的参数为指针类型（*person），然后在对应的函数体中修改原始数据的值：\nfunc modify(argP *person) {  fmt.Printf(\u0026#34;address of arg p: %p\\n\u0026#34;, argP)  argP.name = \u0026#34;Nobody\u0026#34;  argP.age = 10 } 这样，就Ok了。\n看到输出：\naddress of p: 0xc000290450 {Mike 19} address of arg p: 0xc000290450 {Nobody 10} 引用类型 引用类型，包括 map 跟 chan\nmap 同样是上述的例子，我们不试用自定义结构体 person，而是使用map来达到修改的目的：\nfunc main(){  m := make(map[string]int)  m[\u0026#34;age\u0026#34;] = 19  fmt.println(m)  modify(m)  fmt.Println(m) }  func modify(p map[string]int){  p[\u0026#34;age\u0026#34;] = 10 } 可以看到输出如下：\nmap[age:19] map[age:10] 同样达到了我们修改值这个期望，因为 map 是一个引用类型，在go语言中，无论是通过字面量还是make函数创建的map，go语言编译器都会自动帮我们转化成为对 runtime.makemap 的调用，rumtime.makemap的定义如下：\n// makemap implements Go map creation for make(map[k]v, hint). func makemap(t *maptype, hint int, h *hmap) *hmap{  //省略无关代码 } 可以看到，这个函数最终返回的是 *hmap 类型，而他本质上就是一个指针。因此，我们才可以通过在函数内修改map的值，达到修改原始数据的目的。\n需要注意的是，map在这里被理解为引用类型，但是它的本质上就是一个指针。\nchan 作为goroutine中的通信桥梁，channel也是可以被理解为引用类型，本质上也是一个指针\n同map一样，go语言也会帮我们自动调用 runtime.makechan函数，创建一个channal：\nfunc makechan(t *chantype, size int64) *hchan {  //省略无关代码 } 可以看到，返回的是一个 *hchan，本质上也是一个指针，同map一样。\n严格来说，GO语言没有引用类型，将map、chan成为引用类型是为了便于理解。此外，go语言中的函数、接口、slice切片、指针类型等，也可以成为引用类型。\n类型的零值 在go中，定义变量要么通过声明，要么通过make和new函数，不一样的是make和new函数属于显式声明并初始化，如果我们声明的变量没有显式声明初始化，则该变量的默认值就是对应类型的零值：\n   类型 零值     数值类型（int、float等） 0   bool false   string \u0026ldquo;\u0026quot;（空字符串）   struct 内部字段的零值   slice、map、指针、函数、chan、interface nil    总结 在go语言中，函数的参数传递只有值传递，而且传递的实参都是原始数据的一份拷贝。\n 如果拷贝的内容都是值类型的，那么在函数中就无法修改原始数据 如果拷贝内容是指针，则可以在函数中修改原始数据  ","permalink":"https://zihuanling.github.io/posts/go-11-depth/","summary":"值类型 假设我们有一个这样的结构体：\ntype person struct {  name string  age uint } 然后我们试图定义一个函数，修改这个结构体实例的值：\nfunc modify(argP person){  argP.name = \u0026#34;Nobody\u0026#34;  argP.age = 10 }  // 我们实际运行一下这个函数 func main(){  p := person{name: \u0026#34;mike\u0026#34;, age: 19}  fmt.Println(p)  modify(p)  fmt.Println(p) } 上述的例子中，我们期望在经过了modify函数修改后，打印出来的结果是 {Nobody, 10}，然而实际上，输出的仍然是初始化的值： {mike, 19}\n为啥会这样呢，因为上面定义的变量 p 是值类型，而通过modify函数传入的变量值argP只是原始值变量p的一份值拷贝，而不是原来的数据本身。\n其实，我们只要在modify函数内部和外部打印出变量p和argP的地址，就可以发现他们的不同之处。\nfunc modify(argP person){  fmt.Printf(\u0026#34;address of arg p: %p\\n\u0026#34;, \u0026amp;argP)  // ... }  func main(){  // .","title":"11. go深入：值、指针以及引用类型"},{"content":"由于我的博客文章里面用到了mermaid绘制流程图，从Jekyll迁移到Hugo之后，使用的PaperMod主题是默认不支持mermaid渲染的，搜了很多帖子，看到有很多解决办法。\n比如有定义 /layouts/shortcodes/mermaid.html 的，然后在代码里面，需要用到mermaid的地方（文章里面）这样写：\n{{ \u0026lt;mermaid\u0026gt; }} ... 这里写mermaid内容 {{ \u0026lt;/mermaid\u0026gt; }} 但是这样的写法不是我想要的，我想要的是保留原来的写法，能够在渲染成html的时候，动态渲染 .language-mermaid 这个类的元素为 mermaid代码块。\n查了一下PaperMod这个主题的代码，发现预留了 extend_head.html 这个扩展html头，太棒了！我们就可以在不改变原有主题代码的情况下，增添自己的head内容！\n首先，我们新建一个文件： layouts/partials/extend_head.html，然后在里面写上mermaid的初始化代码：\n\u0026lt;!-- 使用cdn加载文件 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 自定义mermaid配置 const config = {  startOnLoad:true,  theme: \u0026#39;forest\u0026#39;,  themeVariables: {  lineColor: \u0026#34;#fafafa\u0026#34; // 由于paperMod的代码块背景是黑色的，这里将线条设置为白色  },  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); // 需要注意的是，要将初始化代码放到 window.onload 回调函数里面才有用 // 否则会因为在html元素加载前进行初始化，找不到元素而失效 window.onload = () =\u0026gt; {  window.mermaid.init(undefined, document.querySelectorAll(\u0026#39;.language-mermaid\u0026#39;)); } \u0026lt;/script\u0026gt; Ok！现在，我的文章就可以支持使用mermaid画图了！\ngraph LR Hello --\u0026gt; Mermaid --\u0026gt; Yes ","permalink":"https://zihuanling.github.io/posts/hugo-papermod-mermaid/","summary":"由于我的博客文章里面用到了mermaid绘制流程图，从Jekyll迁移到Hugo之后，使用的PaperMod主题是默认不支持mermaid渲染的，搜了很多帖子，看到有很多解决办法。\n比如有定义 /layouts/shortcodes/mermaid.html 的，然后在代码里面，需要用到mermaid的地方（文章里面）这样写：\n{{ \u0026lt;mermaid\u0026gt; }} ... 这里写mermaid内容 {{ \u0026lt;/mermaid\u0026gt; }} 但是这样的写法不是我想要的，我想要的是保留原来的写法，能够在渲染成html的时候，动态渲染 .language-mermaid 这个类的元素为 mermaid代码块。\n查了一下PaperMod这个主题的代码，发现预留了 extend_head.html 这个扩展html头，太棒了！我们就可以在不改变原有主题代码的情况下，增添自己的head内容！\n首先，我们新建一个文件： layouts/partials/extend_head.html，然后在里面写上mermaid的初始化代码：\n\u0026lt;!-- 使用cdn加载文件 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 自定义mermaid配置 const config = {  startOnLoad:true,  theme: \u0026#39;forest\u0026#39;,  themeVariables: {  lineColor: \u0026#34;#fafafa\u0026#34; // 由于paperMod的代码块背景是黑色的，这里将线条设置为白色  },  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); // 需要注意的是，要将初始化代码放到 window.onload 回调函数里面才有用 // 否则会因为在html元素加载前进行初始化，找不到元素而失效 window.onload = () =\u0026gt; {  window.","title":"让Hugo Papermod主题支持 Mermaid"},{"content":"在 Jinja2 模板中，我们经常需要判断一个变量是否存在，里面的值是否为空等等。\n检查变量是否存在，或者是否被定义 {% if variable is defined %}  variable is defined {% else %}  variable is not defined {% endif %} 检查数据的长度是否为空 对于列表类型的变量，我们可能需要知道这个列表是否为空的\n{% if variable | length %}  variable is not empty {% else %}  variable is empty {% endif %} 需要注意的是，如果这个变量为非列表类型，模板渲染的时候会报错\n检查变量值是否为True {% if variable is sameas true %}  variable is true {% else %}  variable is not true {% endif %} 同样，我们也可以用关键字and来实现多个判断 判断变量存在且不为空（列表型变量） {% if variable is defined and variable | length %}  variable is defined and is not empty {% else %}  variable is not defined or empty {% endif %} 判断变量存在且为true（布尔型变量） {% if variable is defined and is sameas true %}  variable is defined and is true {% else %}  variable is not defined or not true {% endif %} ","permalink":"https://zihuanling.github.io/posts/2022-03-09-jinja-templates-variable-judgement/","summary":"在 Jinja2 模板中，我们经常需要判断一个变量是否存在，里面的值是否为空等等。\n检查变量是否存在，或者是否被定义 {% if variable is defined %}  variable is defined {% else %}  variable is not defined {% endif %} 检查数据的长度是否为空 对于列表类型的变量，我们可能需要知道这个列表是否为空的\n{% if variable | length %}  variable is not empty {% else %}  variable is empty {% endif %} 需要注意的是，如果这个变量为非列表类型，模板渲染的时候会报错\n检查变量值是否为True {% if variable is sameas true %}  variable is true {% else %}  variable is not true {% endif %} 同样，我们也可以用关键字and来实现多个判断 判断变量存在且不为空（列表型变量） {% if variable is defined and variable | length %}  variable is defined and is not empty {% else %}  variable is not defined or empty {% endif %} 判断变量存在且为true（布尔型变量） {% if variable is defined and is sameas true %}  variable is defined and is true {% else %}  variable is not defined or not true {% endif %} ","title":"Jinja2: 判断变量是否为空、存在等"},{"content":"什么是指针 可以简单将指针理解为内存地址。\n指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象，可以是整型、字符串、或者是我们自定义的任意结构体类型。\n也可以理解为：指针就是一本书上的目录上面的页码，这个页码指向具体的内容。\n指针的声明和定义 以字符串指针为例\n// 声明一个字符串指针变量 var sp *string // 直接通过 \u0026amp; 操作符获取一个字符串的地址 s := \u0026#34;Hello world.\u0026#34; sp := \u0026amp;s // 还可以使用 new 函数，传入一个类型作为参数，用以返回该类型的指针 sp := new(string) 指针的操作 针对指针的操作，有两种：获取或者修改指针指向的值\n 获取指针指向的值  使用 *指针变量 获取指针指向的值，如 *sp 获取sp指针指向的内存地址的值。\n修改指针指向的值  修改跟获取值也是类似的，使用 *指针变量 = 值 来修改，如 *sp = \u0026quot;new value\u0026quot;，这样，就把 sp指针指向的内存地址值修改为了 new value\n注意 另外，通过 var sp *string 定义的sp指针，初始值是nil，表示它没有指向任何一块内存地址，我们不能够对它进行取值和赋值操作，否则，会提示：\ninvalid memory address or nil pointer dereference\n要解决这个问题，只需要使用 new 函数给该地址分配一块内存即可：\nvar sp *string = new(string)\n还有就是，不能获取常量的指针。\n指针参数 当我们需要在函数中通过形参改变实参的值是，需要使用指针类型的参数\n举个栗子，我们有个 increase 函数，每次调用的时候，我们就让传入的参数加一\n无效写法：\nfunc increase(num int){  num++ } 上述修改的只是形参传入的值，外部的实参没有变化\n有效写法：\nfunc increase(num *int){  *num++ } 指针接收者 一点复习\n 如果接收者类型是 map、slice、channel 这类引用类型，不使用指针 如果需要修改接收者，需要使用指针 如果接收者是比较大的类型，可以考虑使用指针，因为内存拷贝廉价，所以效率更高。  指针的两大好处  可以修改指向数据的值 在变量赋值、参数传值的时候可以节省内存  使用建议  不要多map、slice、channel这类引用类型使用指针 如果需要修改方法接收者内部的数据或者状态时，需要使用指针 如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数 如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针 像int、bool这样的小数据类型没有必要使用指针 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全，比如加锁之类的 指针最好不要嵌套，也就是不要使用一个指向指针的指针，这会让代码变得复杂。  指向接口的指针是否实现了该接口？ 答案是：没有\n看个例子：\n// 定义一个结构体 address，其实现了 fmt.Stringer 接口 type address stuct {  city string  province string }  func (addr address) String() string {  return fmt.Sprintf(\u0026#34;Address is %s/%s\u0026#34;, addr.province, addr.city) }  // 然后，我们定义一个调用 Stringer 的打印函数 func printer(s fmt.Stringer) {  fmt.Println(\u0026#34;string value is : \u0026#34;, s.String()) } 一般情况下，我们知道，值接收者实现了Stringer接口，那么它的值类型和指针类型也实现了该接口。\n因此，我们可以这样调用：\nfunc main(){  addr := address{city: \u0026#34;Shenzhen\u0026#34;, province: \u0026#34;GuangDong\u0026#34;}  // 验证值类型接收者  printer(addr)  // 验证指针类型接收者  printer(\u0026amp;addr) } 这些都是没有问题的，我们接下来验证下指向接口的指针是否实现了该接口\nfunc main(){  // 声明一个 Stringer 接口 si，因为 address实现了 Stringer接口，因此可以直接赋值给si  var si fmt.Stringer := address{city: \u0026#34;Shenzhen\u0026#34;, province: \u0026#34;GuangDong\u0026#34;}  // 调用 printer 打印 si，没有问题  printer(si)  // 来一个指向si的指针sip（指向接口的指针）  sip := \u0026amp;si  // 看看sip是否实现了Stringer接口  printer(sip) } 最后，printer(sip) 这句会编译不通过，提示 Cannot use '\u0026amp;si' (type *fmt.Stringer) as type fmt.Stringer\n所以结论是：虽然指向具体类型的指针可以实现一个接口，但是指向接口的指针永远不可能实现该接口\n","permalink":"https://zihuanling.github.io/posts/2022-03-06-go-10-depth/","summary":"什么是指针 可以简单将指针理解为内存地址。\n指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象，可以是整型、字符串、或者是我们自定义的任意结构体类型。\n也可以理解为：指针就是一本书上的目录上面的页码，这个页码指向具体的内容。\n指针的声明和定义 以字符串指针为例\n// 声明一个字符串指针变量 var sp *string // 直接通过 \u0026amp; 操作符获取一个字符串的地址 s := \u0026#34;Hello world.\u0026#34; sp := \u0026amp;s // 还可以使用 new 函数，传入一个类型作为参数，用以返回该类型的指针 sp := new(string) 指针的操作 针对指针的操作，有两种：获取或者修改指针指向的值\n 获取指针指向的值  使用 *指针变量 获取指针指向的值，如 *sp 获取sp指针指向的内存地址的值。\n修改指针指向的值  修改跟获取值也是类似的，使用 *指针变量 = 值 来修改，如 *sp = \u0026quot;new value\u0026quot;，这样，就把 sp指针指向的内存地址值修改为了 new value\n注意 另外，通过 var sp *string 定义的sp指针，初始值是nil，表示它没有指向任何一块内存地址，我们不能够对它进行取值和赋值操作，否则，会提示：\ninvalid memory address or nil pointer dereference\n要解决这个问题，只需要使用 new 函数给该地址分配一块内存即可：\nvar sp *string = new(string)","title":"10. go深入：Go 中的指针"},{"content":"for select 模式 这是一种常见的并发模式，我们一般使用 for {}  死循环，然后里面加select配合channel，获取协程的终止信号，来控制协程的退出\nfor {  select {  case \u0026lt;- done:  // received stop signal, stopping.  return  default: \t// processing ...  } } 类似的还有 for range select模式，主要就是使用 for ... range 遍历某个数据数组，将数据发送到channel里面：\nfor _, value := range []int{} {  select {  case \u0026lt;- done:  // 接受到终止信号  return  case resultCh \u0026lt;- value:  // do nothing but put value to rsult channel  } } select timeout 模式 select timeout模式，核心在于使用 time.After(t time.Duration) 返回一个定时的channel，使用select配合这个channel控制协程的退出。\n来看一个网络访问超时的demo：\nfunc main(){  result := make(chan string)  go func(){  // simulate internet visiting...  time.Sleep(5 * time.Second)  result \u0026lt;- \u0026#34;Done, internet visited.\u0026#34;  }()  select {  case v := \u0026lt;-result:  fmt.Println(\u0026#34;result from internet: \u0026#34;, v)  case \u0026lt;- time.After(3 * time.Second): \tfmt.Println(\u0026#34;Timeout!\u0026#34;)  } } pipeline 模式 pipeline流水线模式，顾名思义，就是整一个生产流程中有多个工序，后面的工序依赖前面一道工序的结果。\n或者说，前面工序的输出，就是后面工序的输入。\ngraph LR 生产:::point --\u0026gt; 工序1 --\u0026gt; 工序2 --\u0026gt; 工序3 --\u0026gt; 成品:::point classDef point fill:#f88; 我们以酒席的上菜流程来看，我们将其作为一个流水线，简化为3个步骤：\n 洗菜 炒菜 端菜上桌  洗菜:\n// n表示需要处理的菜品数量 // 返回一个channel，用户传递洗好的菜 func wash(n int) \u0026lt;-chan string {  washedCh := make(chan string)  go func(){  defer close(washedCh)  for i := 1; i \u0026lt;= n; i++ {  washedCh \u0026lt;- fmt.Sprintf(\u0026#34;洗好的菜%d\u0026#34;, i) \t} \t}()  return washedCh } 炒菜：\n// 炒菜，传入channel，里面是洗好的菜 // 返回一个channel，里面是炒好的菜 func fire(washed \u0026lt;-chan string) \u0026lt;-chan string { \tfiredCh := make(chan string) \tgo func() { \tdefer close(firedCh) \tfor w := range washed { \tfiredCh \u0026lt;- fmt.Sprintf(\u0026#34;炒好的【%s】\u0026#34;, w) \t} \t}() \treturn firedCh } 上菜：\n// 传菜，传入channel，里面是炒好的菜，我们负责将菜端到各桌 func deliver(fired \u0026lt;-chan string) { \tfor food := range fired { \tfmt.Printf(\u0026#34;已上桌： %s\\n\u0026#34;, food) \t} } 完整的酒席流程：\n三个工序（步骤）我们已经定义好了，接下来将其组装成为一个完整的流程：\nfunc main() { \twashed := wash(10) \tfired := fire(washed) \tdeliver(fired) } 流程输出记录如下：\n已上桌： 炒好的【洗好的菜1】 已上桌： 炒好的【洗好的菜2】 已上桌： 炒好的【洗好的菜3】 已上桌： 炒好的【洗好的菜4】 已上桌： 炒好的【洗好的菜5】 已上桌： 炒好的【洗好的菜6】 已上桌： 炒好的【洗好的菜7】 已上桌： 炒好的【洗好的菜8】 已上桌： 炒好的【洗好的菜9】 已上桌： 炒好的【洗好的菜10】 扇出扇入模式 原来的模式是这样的：\ngraph LR 洗菜 --\u0026gt; 厨师炒菜 --\u0026gt; 端菜上桌 每道步骤都只有一个人，但是，洗菜是比较快的（假设不是很麻烦的菜，随便洗洗那种），炒菜却需要较长的时间，厨师需要配菜、掌控火候、调味装盘等。\n所以，上述流程的性能瓶颈便是炒菜\n在厨师炒菜的过程中，服务员需要等待菜炒好了才能端菜，这段时间便会空闲下来，没有充足的利用到资源，造成了浪费。\n我们使用扇出扇入模式对上述流程进行改造：\ngraph LR subgraph 扇出 洗菜 end 洗菜 --chan--\u0026gt; 厨师1炒菜 --chan--\u0026gt; 合并 洗菜 --chan--\u0026gt; 厨师2炒菜 --chan--\u0026gt; 合并 洗菜 --chan--\u0026gt; 厨师3炒菜 --chan--\u0026gt; 合并 subgraph 扇入 合并 end 合并 --chan--\u0026gt; 端菜上桌 主要改造内容就是：调用多个厨师来炒菜，然后将炒好的菜汇合在一起，服务员进行端菜。\n首先，我们对炒菜函数进行改造，主要是加入一个参数cooker，用于区分当前菜品是哪个厨师炒的：\n// 炒菜，传入channel，里面是洗好的菜, cooker 表示厨师的名字 // 返回一个channel，里面是炒好的菜 func fire(washed \u0026lt;-chan string, cooker string) \u0026lt;-chan string { \tfiredCh := make(chan string) \tgo func() { \tdefer close(firedCh) \tfor w := range washed { \tfiredCh \u0026lt;- fmt.Sprintf(\u0026#34;%s炒好的【%s】\u0026#34;, cooker, w) \t} \t}() \treturn firedCh } 然后实现菜品汇合部分的代码：\n// 将炒好的菜汇合在一起，提供给服务员端菜 func merge(fireds ...\u0026lt;-chan string) \u0026lt;-chan string {  // 所有的菜品都将汇合到 merged channel 里面 \tmerged := make(chan string) \tvar wg sync.WaitGroup \tgo func() { \twg.Add(len(fireds)) \tdefer close(merged) \tfor _, fired := range fireds { \tgo func(foods \u0026lt;-chan string) { \tdefer wg.Done() \tfor food := range foods { \tmerged \u0026lt;- food \t} \t}(fired) \t} \twg.Wait() \t}() \treturn merged } 最后！我们改造下main函数，让多个厨师炒菜，然后实现 菜品汇合 -\u0026gt; 端菜\nfunc main() { \twashed := wash(10)  // 3个厨师炒菜 \tfired1 := fire(washed, \u0026#34;cooker1\u0026#34;) \tfired2 := fire(washed, \u0026#34;cooker2\u0026#34;) \tfired3 := fire(washed, \u0026#34;cooker3\u0026#34;)  // 汇合菜品 \tmerged := merge(fired1, fired2, fired3)  // 端菜 \tdeliver(merged) } 流程输出记录：\n已上桌： cooker3炒好的【洗好的菜3】 已上桌： cooker3炒好的【洗好的菜4】 已上桌： cooker1炒好的【洗好的菜1】 已上桌： cooker1炒好的【洗好的菜7】 已上桌： cooker3炒好的【洗好的菜5】 已上桌： cooker1炒好的【洗好的菜8】 已上桌： cooker3炒好的【洗好的菜10】 已上桌： cooker1炒好的【洗好的菜9】 已上桌： cooker2炒好的【洗好的菜2】 已上桌： cooker2炒好的【洗好的菜6】 可以看到，各个菜品的上菜时间是无序的，也就是说，哪道菜先做好就先上，大大提高了上菜效率，不会让客人久等了！\nFutures 模式 流水线 Pipeline模式中的各个步骤都是相互依赖的，只有上一个工序完成，下一个工序才能开始。\nFutures模式：实际需求中，很多任务是独立的，比如说煲汤、煮饭和炒菜，我们可以同时煲汤、煮饭，不需要立刻获取到煮好的汤和饭，可以先去做其他的事情，比如炒菜，然后在未来的某个时候，去获取煲汤和煮饭的结果，这就是未来模式（Futrues模式）\n以上述的煲汤、煮饭、炒菜为例，代码实现一下：\nfunc main() { \tfmt.Println(\u0026#34;开始做饭\u0026#34;) \triceCh := rice() \tsoupCh := soup() \tfmt.Println(\u0026#34;去做其他事情。。。\u0026#34;) \tfmt.Println(\u0026#34;开始炒菜吧。。。\u0026#34;) \ttime.Sleep(2 * time.Second) \tfmt.Println(\u0026#34;菜炒好了！\u0026#34;) \tr := \u0026lt;-riceCh \ts := \u0026lt;-soupCh \tfmt.Printf(\u0026#34;吃饭！ 菜、%s、喝 %s\\n\u0026#34;, r, s) }  // 煮饭 func rice() \u0026lt;-chan string { \tfmt.Println(\u0026#34;开始煮饭啦\u0026#34;) \tch := make(chan string) \tgo func() { \ttime.Sleep(3 * time.Second)\t// 煮饭耗时 \tch \u0026lt;- \u0026#34;煮好的饭\u0026#34; \tfmt.Println(\u0026#34;饭煮好了！\u0026#34;) \t}() \treturn ch } // 煲汤 func soup() \u0026lt;-chan string { \tfmt.Println(\u0026#34;开始煲汤啦！\u0026#34;) \tch := make(chan string) \tgo func() { \ttime.Sleep(4 * time.Second)\t// 煲汤耗时 \tch \u0026lt;- \u0026#34;煲好的汤\u0026#34; \tfmt.Println(\u0026#34;汤煲好了\u0026#34;) \t}() \treturn ch } Futures 模式下的协程和普通协程最大的区别是可以返回结果，而这个结果会在未来的某个时间点使用。所以在未来获取这个结果的操作必须是一个阻塞的操作，要一直等到获取结果为止。\n如果大任务可以拆解为一个个独立并发执行的小任务，并且可以通过这些小任务的结果得出最终大任务的结果，就可以使用 Futures 模式\n最后 并发模式和设计模式很相似，都是对现实场景的抽象封装，以便提供一个统一的解决方案。但和设计模式不同的是，并发模式更专注于异步和并发。\n","permalink":"https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/","summary":"for select 模式 这是一种常见的并发模式，我们一般使用 for {}  死循环，然后里面加select配合channel，获取协程的终止信号，来控制协程的退出\nfor {  select {  case \u0026lt;- done:  // received stop signal, stopping.  return  default: \t// processing ...  } } 类似的还有 for range select模式，主要就是使用 for ... range 遍历某个数据数组，将数据发送到channel里面：\nfor _, value := range []int{} {  select {  case \u0026lt;- done:  // 接受到终止信号  return  case resultCh \u0026lt;- value:  // do nothing but put value to rsult channel  } } select timeout 模式 select timeout模式，核心在于使用 time.","title":"9. go并发：Go 中的并发模式"},{"content":"目前，github page 会将 markdown里面的 mermaid 块渲染成为一个 div.language-mermaid 的 html 代码块，但是，mermaid-js仅支持渲染 div.mermaid 的html代码块，因此，我们需要做一点处理。\n我们只需要在文章模板的末尾，添加如下转化代码即可：\n文件：_layouts/post.html {%- if content contains \u0026#39;mermaid\u0026#39; -%} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const config = {  startOnLoad:true,  theme: \u0026#39;forest\u0026#39;,  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll(\u0026#39;.language-mermaid\u0026#39;)); \u0026lt;/script\u0026gt; {% endif %} 上述代码手动将 div.language-mermaid 添加到 mermaid引擎的渲染中。\n引用 在文章里面指定文章layout，即可引用，并且渲染mermaid！\n--- layout: post --- 其他方法 当然也可以在 _config.yml 配置kramdown, 让其可以将 mermaid 块渲染成 div.mermaid 这样的html的代码块，但是实现起来有点复杂。\n参考： Issue https://github.com/gettalong/kramdown/issues/637\n","permalink":"https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/","summary":"目前，github page 会将 markdown里面的 mermaid 块渲染成为一个 div.language-mermaid 的 html 代码块，但是，mermaid-js仅支持渲染 div.mermaid 的html代码块，因此，我们需要做一点处理。\n我们只需要在文章模板的末尾，添加如下转化代码即可：\n文件：_layouts/post.html {%- if content contains \u0026#39;mermaid\u0026#39; -%} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const config = {  startOnLoad:true,  theme: \u0026#39;forest\u0026#39;,  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll(\u0026#39;.language-mermaid\u0026#39;)); \u0026lt;/script\u0026gt; {% endif %} 上述代码手动将 div.language-mermaid 添加到 mermaid引擎的渲染中。\n引用 在文章里面指定文章layout，即可引用，并且渲染mermaid！\n--- layout: post --- 其他方法 当然也可以在 _config.yml 配置kramdown, 让其可以将 mermaid 块渲染成 div.mermaid 这样的html的代码块，但是实现起来有点复杂。\n参考： Issue https://github.","title":"让github page支持mermaid语法"},{"content":"协程如何退出 一般来说，我们执行协程，需要等到协程执行完毕，才能够退出。但是，当我们想要让协程提前退出，就需要一种机制，去控制协程的退出。\n以下例子使用select + channel的方式，控制协程的退出\n func main() { \tch := make(chan bool) \tvar wg sync.WaitGroup \tgo func() { \tdefer wg.Done()  // 开启looper协程 \tlooper(ch) \t}() \twg.Add(1)  // 5秒后发送中断信号 \ttime.Sleep(time.Second * 5) \tfmt.Println(\u0026#34;Signal to goroutine exit...\u0026#34;) \tch \u0026lt;- true \tfmt.Println(\u0026#34;Signal sent.\u0026#34;) \twg.Wait() // 等待协程完全退出 \tfmt.Println(\u0026#34;Exit.\u0026#34;) }  func looper(ch \u0026lt;-chan bool){ \tfor { \tselect { \tcase \u0026lt;-ch: \tfmt.Println(\u0026#34;go break signal\u0026#34;) \treturn \tdefault: \tfmt.Println(\u0026#34;looper is running...\u0026#34;) \ttime.Sleep(time.Second * 1) \t} \t} } 上述例子通过一个ch channel 发送信号，让协程收到信号后终止循环。\n使用Context控制协程退出 上述，我们可以通过select+ channel 的方式进行控制协程的退出，但是那是单个协程的退出，当我们想要控制多个协程的退出时，也可以用定义多个channel的方法，但是这会让代码变得十分复杂。\n而Context，可以让我们跟踪到每个协程，从而更好地进行限制和控制。\n使用 Context 改造上述的代码：\nfunc main() { \tvar wg sync.WaitGroup \tctx, stop := context.WithCancel(context.Background()) \tgo func() { \tdefer wg.Done() \tlooper(ctx) \t}() \twg.Add(1) \ttime.Sleep(time.Second * 5) \tfmt.Println(\u0026#34;Signal to goroutine exit...\u0026#34;) \tstop()\t// 向context发送停止指令 \tfmt.Println(\u0026#34;Signal sent.\u0026#34;) \twg.Wait() \tfmt.Println(\u0026#34;Exit.\u0026#34;) }  func looper(ctx context.Context){ \tfor { \tselect { \tcase \u0026lt;-ctx.Done(): \tfmt.Println(\u0026#34;go break signal\u0026#34;) \treturn \tdefault: \tfmt.Println(\u0026#34;looper is running...\u0026#34;) \ttime.Sleep(time.Second * 1) \t} \t} } 上述代码实现的功能和使用select + channel也是一样的，主要改动为：\n looper的ch参数改为了ctx context.Context 使用 case \u0026lt;- ctx.Done() 来判断是否接受到终止信号 使用 context.WithCancel(context.Backgroud())来生成一个可以取消的Context，返回两个内容： context和 stop函数，stop函数用于向context发送终止指令。context.Backgroud()用于生成一个空的Context， 一般作为整个Context树的根节点 原来的发送停止指令为向chchannel发送true，作为一个停止的指令，而现在通过调用 stop()来向ctx发送终止信号。  什么是Context Context是一个接口，是并发安全的，具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被Context跟踪的这些协程都会收到取消信号，就可以做清理和退出操作\nContext的代码定义： type Context interface {  Deadline() (deadline time.Time, ok bool)  Done() \u0026lt;-chan struct{}  Err() error  Value(key interface{}) interface{} }  Deadline方法可以获取设置的截止时间，第一个返回的值deadline是截止时间，到了这个时间，Context就会自动发起取消请求，第二个返回值ok表示这个Context是否设置了截止时间。 Done方法返回一个只读的channel，类型为struct{}。协程中，如果该方法返回的chan可以被读取，意味着Context已经发起了终止信号，我们的协程收到这个信号之后，就可以做协程的清理和退出操作了 Err方法返回取消的错误原因，是什么原因导致Contxt被取消。 Value方法可以获取该Context上绑定的值，是一个键值对，需要通过key来获取  最常用的是Done方法，我们用它来判断当前context是否被取消。\nContext树 我们不需要自己实现Context接口，因为Golang提供了多个函数帮助我们生成不同的Context，通过这些函数，我们可以生成一颗Context树，将不同的Context关联起来，这样，当父Context发出取消信号的时候，子Context也会发出该信号，以便控制不同层级的协程退出。\n功能上分，有四种实现好的Context：\n  空Context：context.Backgroud()，不可取消，没有截止时间，主要用于Context的根节点\n  可取消的Context：context.WithCancel(parent context.Context)，用于发送取消信号，当取消时，子Context也会取消\n  可以定时取消的Context：\n context.WithDeadline(parant context.Context, d time.Time)， 设置deadline，在某个时间取消 context.WithTimeout(parant context.Context, timeout time.Duration)， 设置多长时间后自动取消    值Context：context.WithValue(parant context.Context, key, val interface{})，用于存储key-value键值对\n  上述前三种都是可取消的Context，值Context则用于存储key-value键值对\n使用Context取消多个协程 以上述的looper循环例子为例，使用Context同时取消多个协程\n func main() { \tvar wg sync.WaitGroup \twg.Add(4) \tctx, stop := context.WithCancel(context.Background()) \tfor i := 0;i \u0026lt; 3; i++ {  // 启动3个协程，使用父进程ctx控制这些进程的取消 \tgo func(id int) { \tdefer wg.Done() \tlooper(ctx, id) \t}(i) \t} \t// 创建一个子Context，当父Context取消时，subCtx也会发出取消信号 \tsubCtx, _ := context.WithCancel(ctx) \tgo func() { \tdefer wg.Done() \tlooper(subCtx, 3) \tfmt.Println(\u0026#34;looper 3 exist because parent context exit.\u0026#34;) \t}()  \ttime.Sleep(time.Second * 5) \tfmt.Println(\u0026#34;Signal to goroutine exit...\u0026#34;) \tstop()\t// 向context发送停止指令 \tfmt.Println(\u0026#34;Signal sent.\u0026#34;) \twg.Wait() \tfmt.Println(\u0026#34;Exit.\u0026#34;) }  func looper(ctx context.Context, id int){ \tfor { \tselect { \tcase \u0026lt;-ctx.Done(): \tfmt.Printf(\u0026#34;looper %d: go break signal\\n\u0026#34;, id) \treturn \tdefault: \tfmt.Printf(\u0026#34;looper %d is running...\\n\u0026#34;, id) \ttime.Sleep(time.Second * 1) \t} \t} } Context 之间的取消关系图：\ngraph LR Ctx1 --\u0026gt; Ctx2:::canceled Ctx2:::canceled -.cancel.-\u0026gt; Ctx3:::canceled Ctx2:::canceled -.cancel.-\u0026gt; Ctx4:::canceled Ctx1 --\u0026gt; Ctx5 --\u0026gt; Ctx6 classDef canceled fill:#f9a; 可以看到，当节点Ctx2取消时，子节点Ctx4、Ctx5也一同被取消了。如果Ctx4、Ctx5还有更多的子节点的话，也会一并取消。\nContext传值 我们改造上述代码：\nfunc main() { \tvar wg sync.WaitGroup \twg.Add(1)  // 创建一个可取消的parent Context \tctx, stop := context.WithCancel(context.Background())  // 创建一个ValueContext，key为userId, value为1 \tvalCtx := context.WithValue(ctx, \u0026#34;userId\u0026#34;, 1) \tgo func() { \tdefer wg.Done() \tgetUser(valCtx) \t}() \ttime.Sleep(time.Second * 2) \tfmt.Println(\u0026#34;Signal to goroutine exit...\u0026#34;) \tstop()\t// 向context发送停止指令 \tfmt.Println(\u0026#34;Signal sent.\u0026#34;) \twg.Wait() \tfmt.Println(\u0026#34;Exit.\u0026#34;) }  func getUser(ctx context.Context){ \tfor { \tselect { \tcase \u0026lt;-ctx.Done(): \tfmt.Printf(\u0026#34;gorouting [getUser]: go break signal\\n\u0026#34;) \treturn \tdefault: \tvalue := ctx.Value(\u0026#34;userId\u0026#34;) \tfmt.Printf(\u0026#34;gorouting [getUser], userId=%v\\n\u0026#34;, value) \ttime.Sleep(time.Second * 1) \t} \t} } 可以看到，我们通过context.WithValue创建一个含值的Context，然后到goroutine中，在goroutine中通过ctx.Value(\u0026quot;userId\u0026quot;)将我们传入的值获取出来。\n需要注意的是，context.WithValue是没有返回cancelFunc的，也就是说，我们不能够通过值Context主动告诉协程去终止，而是需要创建一个可取消的父Context，通过这个父Context发送取消信号。\nContext使用原则  Context不要放在结构体中，要以参数的方式传递 Context作为函数参数的时候，要作为第一个参数 要使用context.Backgroud()函数生成根节点Context，也就是顶层Context Context传值要传递必须传递的值，而且要尽可能少，不要什么都传 Context多协程安全，可以在多个协程中放心使用  总结：  Context 通过 With 系列函数生成 Context 树，把相关的 Context 关联起来，这样就可以统一进行控制。一声令下，关联的 Context 都会发出取消信号，使用这些 Context 的协程就可以收到取消信号，然后清理退出。我们在定义函数的时候，如果想让外部给函数发取消信号，就可以为这个函数增加一个 Context 参数，让外部的调用者可以通过 Context 进行控制，比如下载一个文件超时退出的需求。\n ","permalink":"https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/","summary":"协程如何退出 一般来说，我们执行协程，需要等到协程执行完毕，才能够退出。但是，当我们想要让协程提前退出，就需要一种机制，去控制协程的退出。\n以下例子使用select + channel的方式，控制协程的退出\n func main() { \tch := make(chan bool) \tvar wg sync.WaitGroup \tgo func() { \tdefer wg.Done()  // 开启looper协程 \tlooper(ch) \t}() \twg.Add(1)  // 5秒后发送中断信号 \ttime.Sleep(time.Second * 5) \tfmt.Println(\u0026#34;Signal to goroutine exit...\u0026#34;) \tch \u0026lt;- true \tfmt.Println(\u0026#34;Signal sent.\u0026#34;) \twg.Wait() // 等待协程完全退出 \tfmt.Println(\u0026#34;Exit.\u0026#34;) }  func looper(ch \u0026lt;-chan bool){ \tfor { \tselect { \tcase \u0026lt;-ch: \tfmt.","title":"8. go并发：Context-多线程并发控制神器"},{"content":"在某些场景中，我们写的bash脚本需要获取命令行中指定的某些参数，用以判断某些条件，或者设置某些变量等。\ngetopts可以让我们通过指定 -a 1 的方式指定对应的参数名称和参数值。\n一个更详细的小教程，可以看这里： getopts_tutorial 使用 可以使用 while getopts \u0026quot;:a:p:\u0026quot; opt; do... 的方式，将参数名称读取到 opt 变量中，然后，在循环体中，使用 $OPTARG 获取到具体的参数值。\n一个小栗子，用于快捷创建新的 gihub pages 博客模板：\n#!/usr/bin/env bash  # 用于快捷创建新博客 # 命令： ./new.sh -t 标签1,标签2 -n 文章标题 -l layout -c 1  layout=\u0026#34;post\u0026#34; title=\u0026#34;new-post\u0026#34; now=$(date +%Y-%m-%d) can_comment=\u0026#34;false\u0026#34; author=\u0026#34;ZihuanLing\u0026#34;  while getopts \u0026#34;:l:t:c:n:\u0026#34; opt; do  case $opt in  l)  layout=\u0026#34;$OPTARG\u0026#34;  ;;  t)  tags=\u0026#34;[$OPTARG]\u0026#34;  ;;  c)  can_comment=\u0026#34;true\u0026#34;  ;;  n)  title=$(echo \u0026#34;$OPTARG\u0026#34; | sed \u0026#34;s/ /\\-/g\u0026#34;)  ;;  \\?) echo \u0026#34;Invalid option -$OPTARG\u0026#34; \u0026gt;\u0026amp;2  exit 1  ;;  esac done  if [ -z $tags ]; then  tags=\u0026#34;[]\u0026#34; fi  filename=\u0026#34;_posts/${now}-${title}.md\u0026#34;  read -r -d \u0026#39;\u0026#39; content \u0026lt;\u0026lt; EOM --- layout: ${layout} title: \u0026#34;${title}\u0026#34; date: ${now} tags: ${tags} comments: ${can_comment} author: ${author} --- \u0026lt;!-- more --\u0026gt; EOM  echo \u0026#34;$filename\u0026#34; echo \u0026#34;$content\u0026#34; echo \u0026#34;$content\u0026#34; \u0026gt; $filename ","permalink":"https://zihuanling.github.io/posts/2022-02-24-try-linux-getopts/","summary":"在某些场景中，我们写的bash脚本需要获取命令行中指定的某些参数，用以判断某些条件，或者设置某些变量等。\ngetopts可以让我们通过指定 -a 1 的方式指定对应的参数名称和参数值。\n一个更详细的小教程，可以看这里： getopts_tutorial 使用 可以使用 while getopts \u0026quot;:a:p:\u0026quot; opt; do... 的方式，将参数名称读取到 opt 变量中，然后，在循环体中，使用 $OPTARG 获取到具体的参数值。\n一个小栗子，用于快捷创建新的 gihub pages 博客模板：\n#!/usr/bin/env bash  # 用于快捷创建新博客 # 命令： ./new.sh -t 标签1,标签2 -n 文章标题 -l layout -c 1  layout=\u0026#34;post\u0026#34; title=\u0026#34;new-post\u0026#34; now=$(date +%Y-%m-%d) can_comment=\u0026#34;false\u0026#34; author=\u0026#34;ZihuanLing\u0026#34;  while getopts \u0026#34;:l:t:c:n:\u0026#34; opt; do  case $opt in  l)  layout=\u0026#34;$OPTARG\u0026#34;  ;;  t)  tags=\u0026#34;[$OPTARG]\u0026#34;  ;;  c)  can_comment=\u0026#34;true\u0026#34;  ;;  n)  title=$(echo \u0026#34;$OPTARG\u0026#34; | sed \u0026#34;s/ /\\-/g\u0026#34;)  ;;  \\?","title":"使用 getopts 获取命令行中的参数"},{"content":"从 lemonchan.github.io fork了这个博客项目，感觉太棒了，设计很简洁，我需要的功能基本上都有。\n感谢！\n","permalink":"https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/","summary":"从 lemonchan.github.io fork了这个博客项目，感觉太棒了，设计很简洁，我需要的功能基本上都有。\n感谢！","title":"第一篇GitHub Page博客"},{"content":"go在并发的时候，可能会出现多个协程同时访问一个资源的时候，这就出现了资源竞争。也可能出现协程还在运行，但是主程序却退出了的情况，这是缺少控制导致的。\n用sync包，可以方便的控制资源的访问，也可以方便实现阻塞等待，让协程执行完毕再退出程序，或者执行下一步。\n资源竞争 在同一个goroutine中，如果分配的内存没有被其他的goroutine访问，只在该goroutine中使用，则不存在资源竞争问题\n如果同一块内存被多个goroutine同时访问，就会产生不知道谁先访问，也无法预料最后结果的情况，这就是资源竞争：\n// 共享的资源 var sum = 0 func main(){  for i := 0; i \u0026lt; 100; i++ {  go add(10)  }  // goroutine 不会阻塞下面的代码，此处Sleep一下，防止main goroutine直接退出  // 而导致未完成的goroutine也被终止  time.Sleep(time.Second * 2)  fmt.Println(\u0026#34;Sum is:\u0026#34;, sum) }  func add(i int) {  sum += i } 上述例子中，sum变量为共享的资源，程序运行的过程中会发生资源竞争。\n 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争\n 同步原语 sync.Mutex 互斥锁，同一个时刻，只有一个goroutine能执行某段代码，其他协程需要等待该协程执行完毕后才能继续执行。\nvar ( \tsum int  mutex sync.Mutex )  func add(i int) {  mutex.Lock()  // defer mutex.Unlock()\t// 使用defer，关闭更加优雅  sum += i  mutex.Unlock() } sync.RWMutex 读写锁\n有几种情况：\n 写的时候不能同时读，这个时候读取的话可能读到脏数据 读的时候不能同时写，也可能产生不可预料的结果 读的时候可以同时读，因为数据不会改变。   // 共享的资源 var ( \tsum = 0 \tmutex sync.RWMutex ) func main(){  for i := 0; i \u0026lt; 100; i++ {  go add(10)  }  for i := 0; i \u0026lt; 10; i++ {  go fmt.Println(\u0026#34;sum is:\u0026#34;, readSum())  }  time.Sleep(time.Second) }  func readSum() int {  // 读取的时候使用RLock（读锁） \tmutex.RLock() \tdefer mutex.RUnlock() \td := sum \treturn d }  func add(i int) { \tmutex.Lock() \tdefer mutex.Unlock() \tsum += i } sync.WaitGroup 上述代码中，我们用到了 time.Sleep 来防止goroutine执行完毕之前，主程序退出。\n由于不知道多个协程执行完毕需要多少时间，因此设置了一个固定的值，调用Sleep\n我们可以使用sync.WaitGroup来监听协程的运行情况：\nfunc main(){  wg := sync.WaitGroup  wg.Add(110) // 监听 110 个goroutine  for i := 0; i \u0026lt; 100; i++ {  go func(){  defer wg.Done()\t// wg计数器减一  add(10)  }()  }  for i := 0; i \u0026lt; 10; i++ {  go func(){  defer wg.Done()  fmt.Println(\u0026#34;sum is : \u0026#34;, readSum())  }()  }  // 一直等待（阻塞），直到计数器为0  wg.Wait() } sync.WaitGroup 的使用步骤:\n 声明一个WaitGroup，wg := sync.WaitGroup,然后调用wg.Add方法，设置需要跟踪的协程数量 在每个协程执行完毕时调用 wg.Done，让计数器值减一，告诉sync.WaitGroup，该协程执行完毕 在需要阻塞的地方，调用wg.Wait方法，知道计数器值为0  sync.Once func main() {  var once sync.Once \tvar wg sync.WaitGroup \twg.Add(10) \tonceBody := func() { \tfmt.Println(\u0026#34;only once.\u0026#34;) \t} \t//启动10个协程执行once.Do(onceBody) \tfor i := 0; i \u0026lt; 10; i++ { \tgo func() { \tdefer wg.Done()  //把要执行的函数(方法)作为参数传给once.Do方法即可 \tonce.Do(onceBody) \t}() \t} \twg.Wait() }\tsync.Once 适用于创建某个对象的单例、只加载一次的资源等只执行一次的场景\nsync.Cond sync.Cond 可以一声令下让所有协程都开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行\nsync.Cond 可以用于控制协程的阻塞和唤醒。\nfunc main() { \tcond := sync.NewCond(\u0026amp;sync.Mutex{}) \tvar wg sync.WaitGroup \twg.Add(11)  // 10 个人赛跑 \tfor i := 1; i \u0026lt;= 10; i++ { \tgo func(num int) { \tdefer wg.Done() \tfmt.Printf(\u0026#34;%-2d is ready.\\n\u0026#34;, num) \tcond.L.Lock()  defer cond.L.Unlock()  cond.Wait()\t// 进入等待，直到 cond.Signal() 或者 cond.Broadcast() \tfmt.Printf(\u0026#34;%-2d is running...\\n\u0026#34;, num) \t}(i) \t} \ttime.Sleep(time.Second)  // 1 个裁判发号施令 \tgo func() { \tdefer wg.Done() \tfmt.Println(\u0026#34;judgement is ready.\u0026#34;) \tfmt.Println(\u0026#34;Run!\u0026#34;) \tcond.Broadcast() // Broadcast 让所有的协程开始运行 \t}() \twg.Wait() } sync.Cond 的三个方法：\n Wait：阻塞当前协程，知道被其他协程调用Broadcast或者Signal方法唤醒，使用的时候需要加锁，直接使用sync.Cond中的锁即可（L字段） Signal：唤醒一个等待时间最长的协程 Broadcast：唤醒所有等待的协程   在调用 cond.Signal 或者 cond.Broadcast 之前，要确保目标协程处于Wait阻塞状态，否则会有死锁问题。\n sync.Map 方法：\n Store：存储一堆key-value值 Load：根据key获取对应的value值，且可判断key是否存在 LoadOrStore：如果key对应的value存在，则返回value；否则，存储对应的value Delete：删除一个key-value键值对 Range：循环迭代sync.Map，效果与for-range一样   func main() { \tvar mp sync.Map \tvar wg sync.WaitGroup \twg.Add(10) \tfor i := 0; i \u0026lt; 10; i++ { \tgo func(id int) { \tdefer wg.Done() \tif _, loaded := mp.LoadOrStore(\u0026#34;initialized\u0026#34;, id); !loaded { \tfmt.Println(id, \u0026#34;mapper not initialized, init now.\u0026#34;) \treturn \t} \tvalue, loaded := mp.LoadOrStore(id, id) \tif loaded { \tfmt.Println(id, \u0026#34;Loaded value \u0026#34;, value) \tif value != id { \tfmt.Println(id, \u0026#34;Insert from other goroutine, delete it\u0026#34;) \tmp.Delete(id) \t} \t} else { \tfmt.Println(id, \u0026#34;Store value \u0026#34;, id) \t} \tmp.Store(id + 1, id) \t}(i) \t} \twg.Wait() \twg.Add(1) \tgo func() { \tdefer wg.Done() \tmp.Range(func(key, value interface{}) bool { \tfmt.Printf(\u0026#34;range for k = %v, value = %v\\n\u0026#34;, key, value) \treturn true \t}) \t}() \twg.Wait() } ","permalink":"https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/","summary":"go在并发的时候，可能会出现多个协程同时访问一个资源的时候，这就出现了资源竞争。也可能出现协程还在运行，但是主程序却退出了的情况，这是缺少控制导致的。\n用sync包，可以方便的控制资源的访问，也可以方便实现阻塞等待，让协程执行完毕再退出程序，或者执行下一步。\n资源竞争 在同一个goroutine中，如果分配的内存没有被其他的goroutine访问，只在该goroutine中使用，则不存在资源竞争问题\n如果同一块内存被多个goroutine同时访问，就会产生不知道谁先访问，也无法预料最后结果的情况，这就是资源竞争：\n// 共享的资源 var sum = 0 func main(){  for i := 0; i \u0026lt; 100; i++ {  go add(10)  }  // goroutine 不会阻塞下面的代码，此处Sleep一下，防止main goroutine直接退出  // 而导致未完成的goroutine也被终止  time.Sleep(time.Second * 2)  fmt.Println(\u0026#34;Sum is:\u0026#34;, sum) }  func add(i int) {  sum += i } 上述例子中，sum变量为共享的资源，程序运行的过程中会发生资源竞争。\n 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争\n 同步原语 sync.","title":"7. go并发：同步原语，用sycn包控制并发"},{"content":"并发，就是让程序在同一时刻做多件事情。\ngo语言天生自带并发属性，使得并发编程十！分！方！便！，我们只需要 go 函数名() 即可！\\(^o^)/\n进程和线程 进程 程序启动时，系统会为其创建一个进程\n线程 是进程的执行空间，一个进程可以包含多个线程，线程被操作系统调度执行 一个程序启动，对应的进程会被创建，同时也会创建一个线程（主线程），主线程结束，整个程序也就退出了。 我们可以从主线程创建其他的子线程，这就是多线程并发\n协程 Goroutine goroutine比线程更加轻盈，被Go runtime调度。 启动协程： go function()\n// 这里启动了两个goroutine， 一个是用go关键字触发的，另一个是 main goroutine（主线程） func main(){  go fmt.Println(\u0026#34;Hello goroutine.\u0026#34;)  fmt.Println(\u0026#34;Main goroutine.\u0026#34;)  time.Sleep(time.Second) } Channel 多个goroutine之间，使用 channel进行通信\n声明一个channel // 直接使用 make 创建一个channel，接受的数据类型是string ch := make(chan string) // 一个channel的操作只有两种： // - 发送，向chan中发送值： chan\u0026lt;- // - 接受，从chan中获取值： \u0026lt;-chan demo\nfunc main(){  ch := make(chan string)  go func(){  fmt.Println(\u0026#34;Message in goroutine\u0026#34;)  ch \u0026lt;- \u0026#34;goroutine finished.\u0026#34;\t// send message to channel.  }()  fmt.Println(\u0026#34;Main goroutine.\u0026#34;)  v := \u0026lt;-ch\t// receive message from channel  fmt.Println(\u0026#34;Message from channel: \u0026#34;, v) }  在上面的示例中，我们在新启动的 goroutine 中向 chan 类型的变量 ch 发送值；在 main goroutine 中，从变量 ch 接收值；如果 ch 中没有值，则阻塞等待到 ch 中有值可以接收为止。\n通过 make 创建的 chan 中没有值，而 main goroutine 又想从 chan 中获取值，获取不到就一直等待，等到另一个 goroutine 向 chan 发送值为止。\nchannel 有点像在两个 goroutine 之间架设的管道，一个 goroutine 可以往这个管道里发送数据，另外一个可以从这个管道里取数据，有点类似于我们说的队列。\n 无缓冲channel 上述的channel就是一个无缓冲的channel，容量为0，无法存储数据，只能传输。 它的发送和接受操作是同时的，可以称为同步channel\n有缓冲channel 类似一个可阻塞的队列，内部的元素先进先出，通过make第二个参数指定channel容量大小：\nch := make(chan int, 5) // 创建一个容量为5的channel 上述创建一个容量为5的channel，可以存放最多5个int类型的元素，其具备以下特点：\n 有缓冲channel内部有一个缓冲队列 发送操作是向队尾插入元素，如果队列已满，则阻塞等待，直到另一个goroutine执行接收操作，释放channel的空间 接收操作是从队头获取一个元素，如果队列已空，阻塞等待，直到有goroutine插入新的元素  关闭channel 使用内置的close函数关闭：\nclose(ch) 如果一个channel被关闭了，就不能向里面发送数据了，继续发送会引发panic异常。\n但是可以接受已关闭channel里面的数据，无数据则接受的是元素类型的零值。\n单向channel 只能发送不能接收，或者只能接收不能发送的channel，成为单向channel\nonlySend := make(chan\u0026lt;- int)\t// 单发 onlyReceive := make(\u0026lt;-chan int)\t// 单收 这样的channel一般在函数或者方法的参数声明中使用：\nfunc counter(sendCh chan\u0026lt;- int){  // 只能往sendCh中发送数据  // num := \u0026lt;-sendCh // 不能从单发channel中接受数据，编译会不通过 } select + channel 示例 // 结构示例 select {  case i1 = \u0026lt;-ch1:  // todo  case ch2 \u0026lt;- i2:  // todo  default:  // default process } 整体结构与switch很像，有case和default，但是select的case是一个个可以操作的channel\n// select 下载例子 func main() {  firstCh := make(chan string)  secondCh := make(chan string)  thirdCh := make(chan string)   go func() { firstCh \u0026lt;- downloadFile(\u0026#34;firstCh\u0026#34;) }()  go func() { secondCh \u0026lt;- downloadFile(\u0026#34;secondCh\u0026#34;) }()  go func() { thirdCh \u0026lt;- downloadFile(\u0026#34;thirdCh\u0026#34;) }()   // select 多路复用，哪个channel最先获取到值，  // 就说明当前channel下载好了  select {  case filePath := \u0026lt;-firstCh:  fmt.Println(filePath)  case filePath := \u0026lt;-secondCh:  fmt.Println(filePath)  case filePath := \u0026lt;-thirdCh:  fmt.Println(filePath)  } }  func downloadFile(filename string) string {  time.Sleep(time.Second)  return \u0026#34;filepath:\u0026#34; + filename }  如果这些 case 中有一个可以执行，select 语句会选择该 case 执行，如果同时有多个 case 可以被执行，则随机选择一个，这样每个 case 都有平等的被执行的机会。如果一个 select 没有任何 case，那么它会一直等待下去。\n 在 Go 语言中，提倡通过通信来共享内存，而不是通过共享内存来通信，其实就是提倡通过 channel 发送接收消息的方式进行数据传递，而不是通过修改同一个变量。所以在数据流动、传递的场景中要优先使用 channel，它是并发安全的，性能也不错。(因为channel内部带有同步互斥锁)\n","permalink":"https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/","summary":"并发，就是让程序在同一时刻做多件事情。\ngo语言天生自带并发属性，使得并发编程十！分！方！便！，我们只需要 go 函数名() 即可！\\(^o^)/\n进程和线程 进程 程序启动时，系统会为其创建一个进程\n线程 是进程的执行空间，一个进程可以包含多个线程，线程被操作系统调度执行 一个程序启动，对应的进程会被创建，同时也会创建一个线程（主线程），主线程结束，整个程序也就退出了。 我们可以从主线程创建其他的子线程，这就是多线程并发\n协程 Goroutine goroutine比线程更加轻盈，被Go runtime调度。 启动协程： go function()\n// 这里启动了两个goroutine， 一个是用go关键字触发的，另一个是 main goroutine（主线程） func main(){  go fmt.Println(\u0026#34;Hello goroutine.\u0026#34;)  fmt.Println(\u0026#34;Main goroutine.\u0026#34;)  time.Sleep(time.Second) } Channel 多个goroutine之间，使用 channel进行通信\n声明一个channel // 直接使用 make 创建一个channel，接受的数据类型是string ch := make(chan string) // 一个channel的操作只有两种： // - 发送，向chan中发送值： chan\u0026lt;- // - 接受，从chan中获取值： \u0026lt;-chan demo\nfunc main(){  ch := make(chan string)  go func(){  fmt.","title":"6. go并发：Goroutines和Channels的声明和使用"},{"content":"正确处理错误，可以让程序更加稳定。error是一个错误接口，一般来说，error是不会影响到整个程序运行的，我们可以自行处理。 而panic是会导致程序直接崩溃退出的，我们也可以用 go自带的recover()来恢复panic，在程序崩溃前进行资源的释放工作。\n错误 error接口 error接口只有一个Error方法，返回具体的错误信息（string）\ntype error interface {  Error() string } 一个字符串转整数的例子：\nfunc main(){  // try to conver alpha \u0026#34;a\u0026#34; to integer  i, err := strconv.Atoi(\u0026#34;a\u0026#34;)  if err != nil {  fmt.Println(err)  } else {  fmt.Println(i)  } } 尝试将字符 a 转换成为 整数，显然是不成功的，因此返回了err\n 一般而言，error 接口用于当方法或者函数执行遇到错误时进行返回，而且是第二个返回值。通过这种方式，可以让调用者自己根据错误信息决定如何进行下一步处理。\n error 工厂函数 除了可以使用其他函数，自己定义的函数也可以返回错误信息给调用者\n自定义error 自定义error就是先自定义一个新的类型，然后实现error接口\n// 自定义一个结构体，携带错误码和具体的错误信息 type commonError struct {  errorCode int\t// 错误码  errorMsg string // 错误信息 }  // 实现error接口 func (ce *commonError) Error() string {  return ce.errorMsg } error 断言 func add(a, b int) int, error {  if a \u0026lt; 0 || b \u0026lt; 0 {  return 0, \u0026amp;commonError{  errorCode: 1,  errorMsg: \u0026#34;a and b must \u0026gt;= 0\u0026#34;  }  }  return a + b, nil }  func main(){  sum, err := add(-1, 2)  // 错误类型断言  if cm, ok := err.(*commonError); ok {  fmt.Printf(\u0026#34;Error code = %d, error message = %s\\n\u0026#34;, cm.errorCode, cm.errorMsg)  } else {  fmt.Printf(\u0026#34;Sum = %d\\n\u0026#34;, sum)  } } 错误嵌套 Error Wrapping 需求，将一个错误嵌套到另一个错误中：\n比如调用一个函数，返回了一个错误信息 error，在不想丢失这个 error 的情况下，又想添加一些额外信息返回新的 error。这时候，我们首先想到的应该是自定义一个 struct，如下面的代码所示：\ntype MyError struct {  err error\t// 指向原有的error  msg string\t// 当前error的错误信息 }  // 上述就是错误的嵌套 // MyError 实现error接口，返回当前错误信息，和原有错误信息 func (me *MyError) Error() string {  return fmt.Sprintf(\u0026#34;Wrapped error: %s -\u0026gt; %s\u0026#34;, me.err.Error(), me.msg) }  func main(){  newError := MyError{err, \u0026#34;New error message.\u0026#34;} } 上述实现方式比较繁琐，从Go 1.13开始，go标准库新增了Error Wrapping功能，我们可以使用 fmt.Errorf 加 %w 的方式，实现错误的嵌套\ne := errors.New(\u0026#34;Original Error\u0026#34;) w := fmt.Errorf(\u0026#34;Wrapped Error: %w\u0026#34;, e) fmt.Println(w) errors.Unwrap 函数 通过 errors.Unwrap 解开嵌套的错误\nerrors.Unwrap(w) // w 是一个嵌套的错误，会返回嵌套前的原始错误 errors.Unwrap(e)\t// e 是一个原始的错误，会返回一个nil errors.Is 函数 使用 Error Wrapping 之后，原来使用 == 判断是否同一个错误的方式失效了\n使用 errors.Is：\nfunc Is(err, target error) bool  如果err和target 是同一个，返回true 如果err是一个wrapping error，且target也包含在这个嵌套的error链中的话，也返回true  errors.As 函数 errors.As是嵌套error的断言\nvar cm *commonError if errors.As(err,\u0026amp;cm){  fmt.Println(\u0026#34;错误代码为:\u0026#34;,cm.errorCode,\u0026#34;，错误信息为：\u0026#34;,cm.errorMsg) } else {  fmt.Println(sum) } Deffered 函数 defer 函数用于保证打开的文件一定会被关闭，功能有点类似于 python 的 with\ndefer 的执行关系是先调用后执行\ndefer func() {fmt.Println(\u0026#34;A\u0026#34;)}() defer func() {fmt.Println(\u0026#34;B\u0026#34;)}() defer func() {fmt.Println(\u0026#34;C\u0026#34;)}() // 最后输出C、B、A defer 有一个调用栈，越早定义越靠近栈的底部，越晚定义月靠近栈的顶部，执行这些defer语句的时候，会先从栈顶弹出一个defer然后执行它。\nPanic 异常 go语言是一门静态的强类型语言，很多问题都尽可能地在编译是捕获，但是有一些只能在运行时检查，比如数组越界访问、不相同的类型强制转换等，这类运行时问题都会引起panic异常。\npanic异常直接将运行中的程序中断\npanic可以接受 interface{}类型的参数（空接口），任何类型的值都可以传到panic\nfunc panic(v interface{})  panic 异常是一种非常严重的情况，会让程序中断运行，使程序崩溃，所以如果是不影响程序运行的错误，不要使用 panic，使用普通错误 error 即可\n 使用Recover捕获panic异常 通常情况下，不需要对panic进行处理，直接让其中断程序即可\n但当我们需要在程序崩溃前做一些资源释放处理时，这时就得从panic恢复，然后进行处理\n我们可以使用go语言内置的recover函数恢复panic异常，只有defer修饰的函数才能在程序崩溃时执行，所以：\nrecover函数要结合defer关键字使用才能生效func connectMysql(ip, username, password string) {  if ip == \u0026#34;\u0026#34; {  panic(\u0026#34;Invalid ip, expect not empty string.\u0026#34;)  } else {  fmt.Printf(\u0026#34;Connecting to ip[] with %s@%s\\n\u0026#34;, ip, username, password)  } }  func main(){  defer func(){  if p := recover(); p != nil {  fmt.Printf(\u0026#34;go panic: %v\u0026#34;, p)  }  }()  connectMysql(\u0026#34;\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;root\u0026#34;) } ","permalink":"https://zihuanling.github.io/posts/2022-02-17-go-5-basic/","summary":"正确处理错误，可以让程序更加稳定。error是一个错误接口，一般来说，error是不会影响到整个程序运行的，我们可以自行处理。 而panic是会导致程序直接崩溃退出的，我们也可以用 go自带的recover()来恢复panic，在程序崩溃前进行资源的释放工作。\n错误 error接口 error接口只有一个Error方法，返回具体的错误信息（string）\ntype error interface {  Error() string } 一个字符串转整数的例子：\nfunc main(){  // try to conver alpha \u0026#34;a\u0026#34; to integer  i, err := strconv.Atoi(\u0026#34;a\u0026#34;)  if err != nil {  fmt.Println(err)  } else {  fmt.Println(i)  } } 尝试将字符 a 转换成为 整数，显然是不成功的，因此返回了err\n 一般而言，error 接口用于当方法或者函数执行遇到错误时进行返回，而且是第二个返回值。通过这种方式，可以让调用者自己根据错误信息决定如何进行下一步处理。\n error 工厂函数 除了可以使用其他函数，自己定义的函数也可以返回错误信息给调用者\n自定义error 自定义error就是先自定义一个新的类型，然后实现error接口\n// 自定义一个结构体，携带错误码和具体的错误信息 type commonError struct {  errorCode int\t// 错误码  errorMsg string // 错误信息 }  // 实现error接口 func (ce *commonError) Error() string {  return ce.","title":"5. go基础：通过 error/deffer/panic 处理错误"},{"content":"函数和方法，大大提高了我们的代码复用率，也提高了代码的可读性。 go语言的函数和方法的定义十分简单，直接使用 func 关键字即可。\n不同于python、C++等有类的概念，而这些类中，又有自己的方法，或者父类的方法。go语言中，我们可以定义一个数据结构，然后给这个数据结构实现自己的方法，同样可以实现【类】的效果，通过组合，同一个结构体中，也可以使用或者覆写其他结构体的方法。\n函数 函数的组成：  关键字 func 函数名 funcName 参数 params 返回值（返回值类型） 函数体  func funcName(params) result { \t// body } // 示例1：普通的函数定义 func sum(a int, b int) int { \treturn a + b } // 示例2：参数表的类型合并，(a int, b int) -\u0026gt; (a, b int) func sum2(a, b int) int { \treturn a + b } // 示例3：多值返回，用 （） 包裹起来 func sum3(a, b int) (int, error) { \tif a \u0026lt; 0 || b \u0026lt; 0 { \treturn 0, errors.New(\u0026#34;invalid params\u0026#34;) \t} \treturn a + b, nil } // 示例4：命名返回参数 // 这里命名的返回值是 res 和 err // 我们可以在函数体中直接使用这两个变量 func sum4(a, b int) (res int, err error) { \tif a \u0026lt; 0 || b \u0026lt; 0 { \t// 可以直接返回 \treturn 0, errors.New(\u0026#34;invalid params\u0026#34;) \t} \t// 也可以给参数赋值，然后return \tres = a + b \terr = nil \treturn } 可变参数 // 这里的可变参数类型是一个切片 func sum5(params ...int) int { \tres := 0 \tfor _, num := range params { \tres += num \t} \treturn res } 需要注意的是，当函数中有普通参数，也有可变参数的时候，那么可变参数一定是放在参数表的最后的。\n包级函数  函数名称的首字母小写代表私有函数，只有在同一个包中才能调用 函数名称的首字母大写代表公有函数，可以在不同的包中被调用 任何一个函数都会从属于一个包  匿名函数和闭包 匿名函数就是没有名称的函数，可以赋值给一个变量\nsum6 := func(a, b int) int { \treturn a + b } fmt.Println(sum6(1, 2)) 闭包：在函数中再定义函数（匿名函数），称为内部函数，这个内部函数可以使用外部函数的变量，这种定义方式称为闭包\nfunc closure() func() int { \t// 这个闭包函数返回一个函数A，这个函数A的返回值类型是 int [func() int] \ti := 0 \treturn func() int { \ti++\t// 这里使用的i是外部函数的变量 i \treturn i \t} }  func main(){ \tcl := closure() \tfmt.Println(cl())\t// 输出 1 \tfmt.Println(cl())\t// 输出 2 \tfmt.Println(cl())\t// 输出 3 } 方法 方法不同于函数，方法需要一个接收者，而函数不需要\n这个接收者是一个类型，这样方法就和这个类型绑定在一起了，称为这个类型的方法\n// 定义一个Age类型 type Age uint func (age Age) String() {  fmt.Println(\u0026#34;age is \u0026#34;, age) } 上述的 String() 就是Age的方法，类型Age是String()的接收者（接收者写在方法名前面，使用小括号()包裹）\n调用方法，可以使用点操作符\nage := Age(20) age.String() 值类型接收者和指针类型接收者  对指针类型接收者的修改是有效的 对值类型接收者的修改是无效的  // 指针类型接收者方法 func (age *Age) Modify(){  *age = Age(30) }  age := Age(20) age.String() // age is 20 age.Modify() // 使用一个值类型变量调用指针类型接收者方法，Go会自动帮我们取指针调用 // （\u0026amp;age).Modify() 跟上述语句是一样的 // 使用指针类型变量调用值类型接收者方法，go会帮我们【解引用调用】 // (\u0026amp;age).String() 同 age.String() age.String() // age is 30  简单地理解为：\n值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。\n 方法是否可以赋值给一个变量 可以\ntype Age uint // 值类型接收者方法 func (age Age) String() {  fmt.Println(\u0026#34;age is \u0026#34;, age) } // 指针类型接收者方法 func (age *Age) Incr() {  *age++ }  age := Age(10) // 值类型接收者方法赋值给变量 sm := Age.String sm(age) // 调用 // 指针类型接收者方法赋值给变量 im := (*Age).Incr im(\u0026amp;age)\t// 调用 sm(age)  不管方法是否有参数，通过方法表达式调用，第一个参数必须是接收者，然后才是方法自身的参数。\n ","permalink":"https://zihuanling.github.io/posts/2022-02-15-go-3-basic/","summary":"函数和方法，大大提高了我们的代码复用率，也提高了代码的可读性。 go语言的函数和方法的定义十分简单，直接使用 func 关键字即可。\n不同于python、C++等有类的概念，而这些类中，又有自己的方法，或者父类的方法。go语言中，我们可以定义一个数据结构，然后给这个数据结构实现自己的方法，同样可以实现【类】的效果，通过组合，同一个结构体中，也可以使用或者覆写其他结构体的方法。\n函数 函数的组成：  关键字 func 函数名 funcName 参数 params 返回值（返回值类型） 函数体  func funcName(params) result { \t// body } // 示例1：普通的函数定义 func sum(a int, b int) int { \treturn a + b } // 示例2：参数表的类型合并，(a int, b int) -\u0026gt; (a, b int) func sum2(a, b int) int { \treturn a + b } // 示例3：多值返回，用 （） 包裹起来 func sum3(a, b int) (int, error) { \tif a \u0026lt; 0 || b \u0026lt; 0 { \treturn 0, errors.","title":"3. go基础：函数和方法"},{"content":"接口是一种聚合类型，结构体是和调用方的一种约定，有点抽象类的意思。:)\n结构体 结构体定义 结构体是一种聚合类型，里面可以包含任意类型的值，这些值就是我们定义的结构体成员，也称为字段\n在go语言中，要定义一个结构体，需要使用 type+struct 关键字组合。\n// 定义一个代表【人】的结构体 type person struct {  name string\t// 名称  age uint\t// 年龄 } 结构体的成员字段并不是必需的，也可以一个字段都没有，这种结构体成为空结构体。\ntype s struct {} 结构体声明使用 // 使用var声明一个person变量，未初始化，里面的值为各自变量的零值 var p person // 可以使用结构体字面量初始化的方式 p2 := person{\u0026#34;Mike\u0026#34;, 10} // 第一个值为 name，第二个值为age，与结构体字段定义顺序有关 // 可以指定字段名初始化，不按定义顺序 p3 := person{age: 10, name: \u0026#34;Mike\u0026#34;} 字段结构体 type address struct {  province string  city string } // 结构体的字段可以是任意类型，也可以是自定义的结构体 type person struct {  name string  age uint  addr address }  // 初始化 p := person{  name: \u0026#34;Mike\u0026#34;,  age: 10,  addr: address{  province: \u0026#34;Guandong\u0026#34;,  city: \u0026#34;Maoming\u0026#34;,  }, } fmt.Println(p.addr.province) 接口 接口的定义 接口是和调用方的一种约定，是一个高度抽象的类型，不需要和具体的实现细节绑定在一起。 接口要做的就是定义好约定，告诉调用方，自己可以做什么，但是不需要知道它的内部是如何实现的 我们通过 type + interface关键字定义一个接口\ntype Stringer interface { \tString() string } 上述我们定义了一个接口 Stringer，这个接口有个方法 String() string\n Stringer是Go SDK的一个接口，属于fmt包\n 接口的实现 接口的实现者必须是一个具体的类型\nfunc (p person) String() string { \treturn fmt.Sprintf(\u0026#34;name = %s, age = %d\u0026#34;, p.name, p.age) } 这里 person 实现了 Stringer接口的 String() 方法 我们接下来实现可以打印Stringer接口方法的函数：\nfunc printString(s fmt.Stringer){ \tfmt.Println(s.String()) } 我们可以调用 printString(p)来打印person的内容，因为 person实现了 fmt.Stringer 这个接口 同样，我们让 address 也实现Stringer接口\nfunc (addr address) String() string { \treturn fmt.Sprintf(\u0026#34;Addr province = %s, city = %s\u0026#34;, addr.province, addr.city) } 然后同样可以调用 printString 来输出： printString(p.addr)\n 这就是面向接口的好处，只要定义和调用双方满足约定，就可以使用，而不用管具体实现。接口的实现者也可以更好的升级重构，而不会有任何影响，因为接口约定没有变。\n 值接收者和指针接收者 调用printString(\u0026amp;p)，可以发现以值类型接收者实现接口的时候，不管是类型本身，还是该类型的指针类型，都实现了改接口\n但是，我们现在将接收者改为指针类型：\nfunc (p *person) String() string { return fmt.Sprintf(\u0026#34;name: %s, age: %d\u0026#34;, p.name, p.age) } 然后调用 printString(p)，将会提示编译不通过，因为person没有实现Stringer接口。 说明：以指针类型接收者实现接口的时候，只有对应的指针类型才被认为实现了该接口\n接口实现规则\n   方法接收者 实现的接口类型     (p person) person 和 *person   (p *person) *person     当值类型作为接收者时，person 类型和*person类型都实现了该接口。 当指针类型作为接收者时，只有*person类型实现了该接口。  工厂函数 工厂函数一般用于创建自定义的结构体，便于使用者调用\nfunc NewPerson(name string) *person { \treturn \u0026amp;person{name: name} }  p1 := NewPerson(\u0026#34;Mike\u0026#34;) 以 errors.New 这个 Go 语言自带的工厂函数为例，演示如何通过工厂函数创建一个接口，并隐藏其内部实现：\n// 工厂函数，返回一个error接口，具体实现是*errorString func New(text string) error { \treturn \u0026amp;errorString{text} }  // 结构体，内部一个字段s，存储错误信息 type errorString struct { \ts string }  // 实现error接口 func (e *errorString) Error() string { \treturn e.s } 继承和组合 在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。\n以io标准包自带的接口为例：\ntype Reader interface {  Read(p []byte) (n int, err error) } type Writer interface {  Write(p []byte) (n int, err error) } // ReadWriter 是 Reader和Writer的组合 type ReadWriter interface {  Reader  Writer } ReadWriter 接口就是 Reader 和 Writer 的组合，组合后，ReadWriter 接口具有 Reader 和 Writer 中的所有方法，这样新接口 ReadWriter 就不用定义自己的方法了，组合 Reader 和 Writer 的就可以了。\n接口可以组合，结构体也可以组合：\ntype address struct {  province string  city string } type person struct {  name string  age uint  address }  // 初始化 p := person{  name: \u0026#34;mike\u0026#34;,  age: 10,  address: address{  province: \u0026#34;Guangdong\u0026#34;,  city: \u0026#34;Maoming\u0026#34;,  }, }  // 像使用自己的字段一样使用address的字段 fmt.Println(\u0026#34;my address is \u0026#34;, p.province, p.city) 类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是方法的覆写。\ntype address struct { \tprovince string \tcity string }  type person struct { \tname string \tage uint \taddress }  func (addr *address) detail() { \tfmt.Printf(\u0026#34;Address detail: province = %s, city = %s\\n\u0026#34;, addr.province, addr.city) }  func (addr *address) who(){ \tfmt.Println(\u0026#34;I am address.\u0026#34;) }  func (p *person) who() { \tfmt.Println(\u0026#34;I am person\u0026#34;) }  p := person{  name: \u0026#34;mike\u0026#34;,  age: 10,  address: address{  province: \u0026#34;Guangdong\u0026#34;,  city: \u0026#34;Maoming\u0026#34;,  }, } p.who()\t// 输出 I am person, 覆写了address.who 方法 p.address.who()\t// 可以调用 address.who，因为方法覆写不会影响到内部的方法实现 p.detail()\t// 输出 Address detail: province = Guangdong, city = Maoming， person没有实现该方法，因此直接调用address的detail方法 p.address.detail()// 输出 Address detail: province = Guangdong, city = Maoming 类型断言 类型断言用来判断一个接口的值是否实现改接口的的某个具体类型\n\u0026lt;接口类型变量\u0026gt;.(断言类型)\n如：\nvar s fmt.Stringer s = p // 断言接口的值 s 是否为一个 person if _, ok := s.(person); ok {  fmt.Println(\u0026#34;person yes\u0026#34;) }else {  fmt.Println(\u0026#34;person no\u0026#34;) } 类型断言会返回两个值 value, ok, 如果类型断言成功，value将会是一个断言对象的实例，如上述代码，断言成功后会返回一个person实例，ok=true，否则，ok=false\n 结构体是对现实世界的描述，接口是对某一类行为的规范和抽象。通过它们，我们可以实现代码的抽象和复用，同时可以面向接口编程，把具体实现细节隐藏起来，让写出来的代码更灵活，适应能力也更强。\n ","permalink":"https://zihuanling.github.io/posts/2022-02-16-go-4-basic/","summary":"接口是一种聚合类型，结构体是和调用方的一种约定，有点抽象类的意思。:)\n结构体 结构体定义 结构体是一种聚合类型，里面可以包含任意类型的值，这些值就是我们定义的结构体成员，也称为字段\n在go语言中，要定义一个结构体，需要使用 type+struct 关键字组合。\n// 定义一个代表【人】的结构体 type person struct {  name string\t// 名称  age uint\t// 年龄 } 结构体的成员字段并不是必需的，也可以一个字段都没有，这种结构体成为空结构体。\ntype s struct {} 结构体声明使用 // 使用var声明一个person变量，未初始化，里面的值为各自变量的零值 var p person // 可以使用结构体字面量初始化的方式 p2 := person{\u0026#34;Mike\u0026#34;, 10} // 第一个值为 name，第二个值为age，与结构体字段定义顺序有关 // 可以指定字段名初始化，不按定义顺序 p3 := person{age: 10, name: \u0026#34;Mike\u0026#34;} 字段结构体 type address struct {  province string  city string } // 结构体的字段可以是任意类型，也可以是自定义的结构体 type person struct {  name string  age uint  addr address }  // 初始化 p := person{  name: \u0026#34;Mike\u0026#34;,  age: 10,  addr: address{  province: \u0026#34;Guandong\u0026#34;,  city: \u0026#34;Maoming\u0026#34;,  }, } fmt.","title":"4. go基础：结构体和接口"},{"content":"数组，大概是每个变成语言都有基础数据结构。\nGo的切片类型（slice）提供了一种方便和有效的方法来处理类型化数据序列（数组）。slice类似于其他语言中的数组，但有一些不同寻常的属性。\nmap可以理解为一个字典。\n数组声明 可以使用 [长度]类型{} 来定义，比如 [2]string{}定义一个长度为2的字符串数组\n这里的长度必须是一个常量，如果要使用变量去动态生成数组的话，需要使用make，如\nmake([]string, size) 这里的size是一个变变量，生成size长度的字符串数组\n另外需要注意的是, [1]string 和 [2]string 不是用一种类型，长度也是数组类型的一部分\n定义数组时可以省略数组的长度，此时会根据大括号{}里面的元素个数推到出数组的长度：\narr := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} 这里会自动生成长度为5的字符串数组，适用于所有元素都被初始化的数据\n但是如果只有特定元素被初始化的数组，就不合适了：\narr := [5]string{1: \u0026#34;a\u0026#34;, 3: \u0026#34;c\u0026#34;} 上述表示数组初始化索引为1的值为a，索引为3的值为c，其他未初始化的为空值（字符串的空值为\u0026quot;\u0026quot;）\n如果我们不指定 [5]string，那么go就会根据我们定义的最大索引值3 来确定数组的长度为4\n数组循环  使用传统的数组循环：  for i := 0; i \u0026lt; len(arr); i++ { \tfmt.Println(arr[i]) }  使用 for range 数组遍历，写法更加简洁  for index, value := range arr { \tfmt.Printf(\u0026#34;index = %v, value = %v\\n\u0026#34;, index, value) } 切片 Slice 切片的区间是左闭右开，如arr[2:5]，选取的索引取数是[2,3,4] 切片的底层是（原）数组，将切片内容修改之后，原数组也会改变\narr := []int{1,2,3,4,5} sliced := arr[1:3] // sliced = {2,3} sliced[0] = 0 // 切片修改后，原数组内容有会改变 // arr = {1, 0, 3, 4, 5} 使用make声明切片 声明一个元素类型为string的切片，长度为5：slice1 := make([]string, 5) 还可以传入一个容量参数：slice2 := make([]string, 4, 8) 这里声明了一个长度为4，容量为8的字符串数组 长度是切片内元素的个数，容量是切片的空间\n 上面的示例说明，Go 语言在内存上划分了一块容量为 8 的内容空间（容量为 8），但是只有 4 个内存空间才有元素（长度为 4），其他的内存空间处于空闲状态，当通过 append 函数往切片中追加元素的时候，会追加到空闲的内存上，当切片的长度要超过容量的时候，会进行扩容。\n 除了make，同样可以通过字面量的方式声明： slice1 := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;}\nAppend 通过内置的append函数对一个切片进行元素追加，返回新的切片\n//追加一个元素 slice2:=append(slice1,\u0026#34;f\u0026#34;) //多加多个元素 slice2:=append(slice1,\u0026#34;f\u0026#34;,\u0026#34;g\u0026#34;) //追加另一个切片 slice2:=append(slice1,slice...) 切片元素循环 可以使用for range，同array一样\nMap映射 map是无序的K-V键值对集合，结构为 map[k]v，k为Key，v为Value key的类型必须支持 ==运算符，以便判断其是或否存在，并保证Key的唯一\nMap的声明初始化 使用内置的make函数进行初始化\n// 创建的map，key类型为string，value类型为int nameAgeMap := make(map[string]int) 赋值： nameAgeMap[\u0026quot;Mike\u0026quot;] = 10\nMap获取和删除 map的操作和数组、切片差不多，都是通过[]操作符，不过切片中的[]是索引，而map的[]是key\n Go 语言的 map 可以获取不存在的 K-V 键值对，如果 Key 不存在，返回的 Value 是该类型的零值，比如 int 的零值就是 0。所以很多时候，我们需要先判断 map 中的 Key 是否存在。\n 如何判断map中是否存在某个值呢 map 的 []操作会返回两个值\n 对应的Value 标记该Key是否存在，存在则该标记为true  mapper := map[string]int{\u0026#34;Mike\u0026#34;: 10, \u0026#34;Lisa\u0026#34;: 11} value, tag := mapper[\u0026#34;Mike\u0026#34;] fmt.Println(value, tag)\t// tag 为true value, tag := mapper[\u0026#34;John\u0026#34;] fmt.Println(value, tag)\t// tag 为false 使用delete删除map中的值 delete(mapper, \u0026quot;Mike\u0026quot;)\n遍历map 使用 for range 十分方便，返回 map的key和value\nmapper := map[string]int{\u0026#34;Mike\u0026#34;: 10, \u0026#34;Lisa\u0026#34;: 11} for key, value := range mapper { \tfmt.Println(key, value) }  需要注意的是 map 的遍历是无序的，也就是说你每次遍历，键值对的顺序可能会不一样。如果想按顺序遍历，可以先获取所有的 Key，并对 Key 排序，然后根据排序好的 Key 获取对应的 Value\n map的大小 和数组切片不一样的是，map是没有容量的，只有长度，获取长度只需要使用len函数即可： fmt.Println(len(mapper))\nstring 和 []byte 字符串string也是一个不可变的字节序列，可以直接转为字节切片 []byte\ns := \u0026#34;你好golang\u0026#34; bs := []byte(s) fmt.Println(bs) // 同样可以使用[] 操作符来获取指定索引的字节值： fmt.Println(s[0], s[11]) // 在go语言中，utf8编码下，一个汉字对应三个字节，因此，s虽然只有8个字符，但是长度却是12。 如果我们想把汉字当成一个长度计算，可以使用utf8.RuneCountInString函数\n","permalink":"https://zihuanling.github.io/posts/2022-02-10-go-2-basic/","summary":"数组，大概是每个变成语言都有基础数据结构。\nGo的切片类型（slice）提供了一种方便和有效的方法来处理类型化数据序列（数组）。slice类似于其他语言中的数组，但有一些不同寻常的属性。\nmap可以理解为一个字典。\n数组声明 可以使用 [长度]类型{} 来定义，比如 [2]string{}定义一个长度为2的字符串数组\n这里的长度必须是一个常量，如果要使用变量去动态生成数组的话，需要使用make，如\nmake([]string, size) 这里的size是一个变变量，生成size长度的字符串数组\n另外需要注意的是, [1]string 和 [2]string 不是用一种类型，长度也是数组类型的一部分\n定义数组时可以省略数组的长度，此时会根据大括号{}里面的元素个数推到出数组的长度：\narr := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} 这里会自动生成长度为5的字符串数组，适用于所有元素都被初始化的数据\n但是如果只有特定元素被初始化的数组，就不合适了：\narr := [5]string{1: \u0026#34;a\u0026#34;, 3: \u0026#34;c\u0026#34;} 上述表示数组初始化索引为1的值为a，索引为3的值为c，其他未初始化的为空值（字符串的空值为\u0026quot;\u0026quot;）\n如果我们不指定 [5]string，那么go就会根据我们定义的最大索引值3 来确定数组的长度为4\n数组循环  使用传统的数组循环：  for i := 0; i \u0026lt; len(arr); i++ { \tfmt.Println(arr[i]) }  使用 for range 数组遍历，写法更加简洁  for index, value := range arr { \tfmt.Printf(\u0026#34;index = %v, value = %v\\n\u0026#34;, index, value) } 切片 Slice 切片的区间是左闭右开，如arr[2:5]，选取的索引取数是[2,3,4] 切片的底层是（原）数组，将切片内容修改之后，原数组也会改变","title":"2. go基础：使用array/slice/map"},{"content":"go最近很火啊，自带高并发，内置网络模块强大，作为后端工程师一枚，自然也要学起来！\ngo 的基础部分跟我们之前学过的大部分语言是都是十分相似的，上手十分简单。\n第一个go程序 第一个程序大都是hello嘛，向新世界打个招呼 :)\nimport fmt  func main(){  fmt.Println(\u0026#34;hello golang!\u0026#34;) } 数据类型以及变量声明的方式 变量声明的方式 // var 变量名 类型 = 表达式 var num int = 1 // 也可以声明变量，但是不赋值 var num int\t// 这样的默认值就是int的默认值 0 // 可以直接赋值并且声明类型 num := 1 // 可以实现多值定义 a, b, c := 1, 2, \u0026#34;hello\u0026#34; var (  a = 1  b = 2  c = \u0026#34;hello\u0026#34; ) 常量声明 常量声明，我们可以直接使用 const 关键字，不需要指定数据的类型，通常，常量我们用大写进行命名\n我们指定变量的值，会自定将变量转为对应的类型\nconst MAX_SIZE = 10 基础类型  整型  有符号：int， int8， int16， int32， int64 无符号：uint，uint8，uint16，uint32，uint64   浮点数：float，float32， float64 布尔型：bool 字符串：string 指针 常量：使用const声明 const name = \u0026quot;Mike\u0026quot;  字符串转换  字符串转数字： strconv.Atoi(\u0026quot;123\u0026quot;) 数字转字符串：strconv.Itoa(123)  数字类型的强制转换：\n int -\u0026gt; float: i2f = float(i) float -\u0026gt; int: f2i = int(f)  3. 控制结构：if/for/switch if // 单纯的if if you == \u0026#34;mike\u0026#34; {  fmt.Println(\u0026#34;Yes, I am mike.\u0026#34;) }  // if + else if you == \u0026#34;mike\u0026#34; {  fmt.Println(\u0026#34;Yes, I am mike.\u0026#34;) } else {  fmt.Println(\u0026#34;No, my name is \u0026#34;, you) }  // if + else if + else if you == \u0026#34;mike\u0026#34; {  fmt.Println(\u0026#34;Yes, I am mike.\u0026#34;) } else if you == \u0026#34;lisa\u0026#34; {  fmt.Println(\u0026#34;Ok, I am lisa.\u0026#34;) } else {  fmt.Println(\u0026#34;No, my name is \u0026#34;, you) } switch  switch 自带break 可以使用fallthrough，让程序执行到下一个条件  switch you { case \u0026#34;mike\u0026#34;:  // yes I am mike case \u0026#34;lisa\u0026#34;:  // yes I am lisa case \u0026#34;john\u0026#34;:  // I am john, fall through to default  fallthrough default:  // nothing match } for // 简单for循环 for i := 0; i \u0026lt; 100; i++ {  // do something... }  // for 实现while循环 for {  // do something  // then break }  // 或者 for i \u0026lt; 100 {  // do something  // increase i  // i++ }  // 使用for range 遍历数组或者其他可迭代对象 nums := []int{1,2,3} for index, num := range nums {  // print(idx, num) } ","permalink":"https://zihuanling.github.io/posts/2022-01-07-go-1-basic/","summary":"go最近很火啊，自带高并发，内置网络模块强大，作为后端工程师一枚，自然也要学起来！\ngo 的基础部分跟我们之前学过的大部分语言是都是十分相似的，上手十分简单。\n第一个go程序 第一个程序大都是hello嘛，向新世界打个招呼 :)\nimport fmt  func main(){  fmt.Println(\u0026#34;hello golang!\u0026#34;) } 数据类型以及变量声明的方式 变量声明的方式 // var 变量名 类型 = 表达式 var num int = 1 // 也可以声明变量，但是不赋值 var num int\t// 这样的默认值就是int的默认值 0 // 可以直接赋值并且声明类型 num := 1 // 可以实现多值定义 a, b, c := 1, 2, \u0026#34;hello\u0026#34; var (  a = 1  b = 2  c = \u0026#34;hello\u0026#34; ) 常量声明 常量声明，我们可以直接使用 const 关键字，不需要指定数据的类型，通常，常量我们用大写进行命名\n我们指定变量的值，会自定将变量转为对应的类型","title":"1. go基础：数据类型，以及控制结构"}]