<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>linux on Coding and Life</title>
    <link>https://zihuanling.github.io/tags/linux/</link>
    <description>Recent content in linux on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 May 2022 22:38:12 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux创建简单的systemd服务</title>
      <link>https://zihuanling.github.io/posts/linux-create-service/</link>
      <pubDate>Wed, 04 May 2022 22:38:12 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/linux-create-service/</guid>
      <description>参考地址：
https://linuxconfig.org/how-to-write-a-simple-systemd-service
https://www.freedesktop.org/software/systemd/man/systemd.service.html
前言 systemd是系统的服务和进程的管理工具，在linux系统下，我们使用 ps aux | head，我们可以看到，系统启动的第一个进程就是systemd。
有时候，我们想要让程序运行在后台，而不是一直在前台，开一个终端挂着。（使用nohup可以实现这个）
有时候，想要在开机的时候就自动启动某个服务，比如redis、mysql、nginx这些，这时候，我们就可以将这些程序的启动编写成为一个服务，这样，在系统启动的时候，systemd会自动加载服务配置，然后启动这些服务。
现在，我想要创建一个python jupyter notebook服务。
创建文件 systemd services存在路径 /etc/systemd/system 下，我们在这路径下创建的 .service 文件，都可以作为系统服务运行。
我们创建一个 notebook.service
vi notebook.service 文件创建完毕后，我们开始编写里面的内容，一个 .service文件里面包含三个关键部分： Unit, Service, Install
Unit 对于一个简单服务来说，我们在 [Unit] 这个块只要写上服务描述就可以了，字段为Description。
[Unit] Description=Jupyter notebook service at port[8080] Serivce [Service] 块是服务配置的集合，这里面的配置声明了该如何去运行这个服务。
[Service] Type=simple ExecStart=/usr/bin/env /root/miniconda3/bin/jupyter notebook Restart=on-failure User=root WorkingDirectory=/tmp/notebook 在Serivce声明中，我们首先要说明这个服务的类型 Type=simple
然后，是最重要的部分，我们需要告诉系统应该去执行什么东西： ExecStart=/usr/bin/env /root/miniconda3/bin/jupyter notebook， 这里，我们指定了执行 jupyter notebook 这个命令，前面加载了用户的环境变量。
随后指定这个服务的重启策略：Restart=on-failure， 我要求的是启动失败后重启
最后，这个服务运行的角色：User=root，以及运行时所在路径： WorkingDirectory=/tmp/notebook
Install [Install] 块声明了当前服务应该应该怎样启用，常用的就是 WantedBy=multi-user.target
[Install] WantedBy=multi-user.</description>
    </item>
    
    <item>
      <title>使用 getopts 获取命令行中的参数</title>
      <link>https://zihuanling.github.io/posts/2022-02-24-try-linux-getopts/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-24-try-linux-getopts/</guid>
      <description>在某些场景中，我们写的bash脚本需要获取命令行中指定的某些参数，用以判断某些条件，或者设置某些变量等。
getopts可以让我们通过指定 -a 1 的方式指定对应的参数名称和参数值。
一个更详细的小教程，可以看这里： getopts_tutorial 使用 可以使用 while getopts &amp;quot;:a:p:&amp;quot; opt; do... 的方式，将参数名称读取到 opt 变量中，然后，在循环体中，使用 $OPTARG 获取到具体的参数值。
一个小栗子，用于快捷创建新的 gihub pages 博客模板：
#!/usr/bin/env bash # 用于快捷创建新博客 # 命令： ./new.sh -t 标签1,标签2 -n 文章标题 -l layout -c 1 layout=&amp;#34;post&amp;#34; title=&amp;#34;new-post&amp;#34; now=$(date +%Y-%m-%d) can_comment=&amp;#34;false&amp;#34; author=&amp;#34;ZihuanLing&amp;#34; while getopts &amp;#34;:l:t:c:n:&amp;#34; opt; do case $opt in l) layout=&amp;#34;$OPTARG&amp;#34; ;; t) tags=&amp;#34;[$OPTARG]&amp;#34; ;; c) can_comment=&amp;#34;true&amp;#34; ;; n) title=$(echo &amp;#34;$OPTARG&amp;#34; | sed &amp;#34;s/ /\-/g&amp;#34;) ;; \?) echo &amp;#34;Invalid option -$OPTARG&amp;#34; &amp;gt;&amp;amp;2 exit 1 ;; esac done if [ -z $tags ]; then tags=&amp;#34;[]&amp;#34; fi filename=&amp;#34;_posts/${now}-${title}.</description>
    </item>
    
  </channel>
</rss>
