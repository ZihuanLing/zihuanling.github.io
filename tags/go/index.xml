<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go on Coding and Life</title>
    <link>https://zihuanling.github.io/tags/go/</link>
    <description>Recent content in go on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Mar 2022 14:34:12 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>14.go深入：SliceHeader，高效的slice</title>
      <link>https://zihuanling.github.io/posts/go-15-slice-header/</link>
      <pubDate>Fri, 18 Mar 2022 14:34:12 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-15-slice-header/</guid>
      <description>数组 数组由两部分组成：数组的大小和数组内部的元素类型。
// 伪代码表示 array {  len  item type } 看以下两个数组的定义：
a1 := [1]string{&amp;#34;mike&amp;#34;} a2 := [2]string{&amp;#34;mike&amp;#34;} 上述定义的两个变量，a1的类型为 [1]string，a2的类型为 [2]string，所以说，数组的大小也属于数组类型的一部分。
数组的两个限制   **一旦一个数组被声明，它的大小和内部的类型就不能改变，**我们将不能随意向其中追加任意多的元素。
  另外，当我们使用数组存储大量数据，然后将数组作为函数的参数进行传值时，由于函数之间是值传递的，因此，数组的拷贝将会耗费巨大的内存。
  slice 切片 我们可以将切片理解为动态的数组。
切片是对数组的封装，它的底层是一个数组存储了所有的元素，但是它可以动态地添加元素，容量不足时可以自动扩容。
动态扩容 使用内置的append方法，向切片中追加元素，返回一个新的切片。
同时，当容量不足的时候，append会自动对切片进行扩容。
func main(){  ss := []string{&amp;#34;mike&amp;#34;} // 定义切片ss  fmt.Printf(&amp;#34;slice before append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss))  ss = append(ss, &amp;#34;lucy&amp;#34;, &amp;#34;john&amp;#34;) // append 追加元素  fmt.Printf(&amp;#34;slice after append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss)) } 输出：</description>
    </item>
    
    <item>
      <title>12.go深入：new、make和内存分配</title>
      <link>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</link>
      <pubDate>Sun, 13 Mar 2022 23:35:38 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</guid>
      <description>Go语言程序所管理的虚拟内存空间会被分为两部分：堆内存和栈内存。栈内存主要由Go语言来管理，开发者无法干涉太多，堆内存则有开发者进行分配。
变量 一个数据类型，在声明之后，会被赋值给一个变量，变量存储了程序所需的数据。
变量的声明 单纯的声明变量，可以使用var关键字，如：
var s string	// 声明一个[字符串]变量，初始值为零值&amp;#34;&amp;#34; var sp *string	// 声明一个[字符串指针]变量，初始值为 nil 变量的初始化 有3种方法
 声明的时候直接初始化： var name string = &amp;quot;mike&amp;quot; 声明之后再进行赋值初始化： name = &amp;quot;mike&amp;quot;,此前 name 变量已经声明 直接使用 := 进行初始化： name := &amp;quot;mike&amp;quot;  值变量和指针变量初始化的区别 我们使用值初始化的时候，可以简单的这样写：
var name string name = &amp;#34;mike&amp;#34; 但是，当我们使用指针初始化的时候：
var nameP *string // 声明一个字符串指针 *nameP = &amp;#34;mike&amp;#34;	// 给nameP指向的地址赋值初始化 这时候，由于 nameP 指向的是一个空地址 nil，我们对这个空地址进行赋值初始化的时候，会报以下错误：
panic: runtime error: invalid memory address or nil pointer dereference 显而易见，我们无法对一个空地址赋值。</description>
    </item>
    
    <item>
      <title>10. go深入：Go 中的指针</title>
      <link>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</guid>
      <description>什么是指针 可以简单将指针理解为内存地址。
指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象，可以是整型、字符串、或者是我们自定义的任意结构体类型。
也可以理解为：指针就是一本书上的目录上面的页码，这个页码指向具体的内容。
指针的声明和定义 以字符串指针为例
// 声明一个字符串指针变量 var sp *string // 直接通过 &amp;amp; 操作符获取一个字符串的地址 s := &amp;#34;Hello world.&amp;#34; sp := &amp;amp;s // 还可以使用 new 函数，传入一个类型作为参数，用以返回该类型的指针 sp := new(string) 指针的操作 针对指针的操作，有两种：获取或者修改指针指向的值
 获取指针指向的值  使用 *指针变量 获取指针指向的值，如 *sp 获取sp指针指向的内存地址的值。
修改指针指向的值  修改跟获取值也是类似的，使用 *指针变量 = 值 来修改，如 *sp = &amp;quot;new value&amp;quot;，这样，就把 sp指针指向的内存地址值修改为了 new value
注意 另外，通过 var sp *string 定义的sp指针，初始值是nil，表示它没有指向任何一块内存地址，我们不能够对它进行取值和赋值操作，否则，会提示：
invalid memory address or nil pointer dereference
要解决这个问题，只需要使用 new 函数给该地址分配一块内存即可：
var sp *string = new(string)</description>
    </item>
    
    <item>
      <title>9. go并发：Go 中的并发模式</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</guid>
      <description>for select 模式 这是一种常见的并发模式，我们一般使用 for {}  死循环，然后里面加select配合channel，获取协程的终止信号，来控制协程的退出
for {  select {  case &amp;lt;- done:  // received stop signal, stopping.  return  default: 	// processing ...  } } 类似的还有 for range select模式，主要就是使用 for ... range 遍历某个数据数组，将数据发送到channel里面：
for _, value := range []int{} {  select {  case &amp;lt;- done:  // 接受到终止信号  return  case resultCh &amp;lt;- value:  // do nothing but put value to rsult channel  } } select timeout 模式 select timeout模式，核心在于使用 time.</description>
    </item>
    
    <item>
      <title>8. go并发：Context-多线程并发控制神器</title>
      <link>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</guid>
      <description>协程如何退出 一般来说，我们执行协程，需要等到协程执行完毕，才能够退出。但是，当我们想要让协程提前退出，就需要一种机制，去控制协程的退出。
以下例子使用select + channel的方式，控制协程的退出
 func main() { 	ch := make(chan bool) 	var wg sync.WaitGroup 	go func() { 	defer wg.Done()  // 开启looper协程 	looper(ch) 	}() 	wg.Add(1)  // 5秒后发送中断信号 	time.Sleep(time.Second * 5) 	fmt.Println(&amp;#34;Signal to goroutine exit...&amp;#34;) 	ch &amp;lt;- true 	fmt.Println(&amp;#34;Signal sent.&amp;#34;) 	wg.Wait() // 等待协程完全退出 	fmt.Println(&amp;#34;Exit.&amp;#34;) }  func looper(ch &amp;lt;-chan bool){ 	for { 	select { 	case &amp;lt;-ch: 	fmt.</description>
    </item>
    
    <item>
      <title>7. go并发：同步原语，用sycn包控制并发</title>
      <link>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</guid>
      <description>go在并发的时候，可能会出现多个协程同时访问一个资源的时候，这就出现了资源竞争。也可能出现协程还在运行，但是主程序却退出了的情况，这是缺少控制导致的。
用sync包，可以方便的控制资源的访问，也可以方便实现阻塞等待，让协程执行完毕再退出程序，或者执行下一步。
资源竞争 在同一个goroutine中，如果分配的内存没有被其他的goroutine访问，只在该goroutine中使用，则不存在资源竞争问题
如果同一块内存被多个goroutine同时访问，就会产生不知道谁先访问，也无法预料最后结果的情况，这就是资源竞争：
// 共享的资源 var sum = 0 func main(){  for i := 0; i &amp;lt; 100; i++ {  go add(10)  }  // goroutine 不会阻塞下面的代码，此处Sleep一下，防止main goroutine直接退出  // 而导致未完成的goroutine也被终止  time.Sleep(time.Second * 2)  fmt.Println(&amp;#34;Sum is:&amp;#34;, sum) }  func add(i int) {  sum += i } 上述例子中，sum变量为共享的资源，程序运行的过程中会发生资源竞争。
 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争
 同步原语 sync.</description>
    </item>
    
    <item>
      <title>6. go并发：Goroutines和Channels的声明和使用</title>
      <link>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</guid>
      <description>并发，就是让程序在同一时刻做多件事情。
go语言天生自带并发属性，使得并发编程十！分！方！便！，我们只需要 go 函数名() 即可！\(^o^)/
进程和线程 进程 程序启动时，系统会为其创建一个进程
线程 是进程的执行空间，一个进程可以包含多个线程，线程被操作系统调度执行 一个程序启动，对应的进程会被创建，同时也会创建一个线程（主线程），主线程结束，整个程序也就退出了。 我们可以从主线程创建其他的子线程，这就是多线程并发
协程 Goroutine goroutine比线程更加轻盈，被Go runtime调度。 启动协程： go function()
// 这里启动了两个goroutine， 一个是用go关键字触发的，另一个是 main goroutine（主线程） func main(){  go fmt.Println(&amp;#34;Hello goroutine.&amp;#34;)  fmt.Println(&amp;#34;Main goroutine.&amp;#34;)  time.Sleep(time.Second) } Channel 多个goroutine之间，使用 channel进行通信
声明一个channel // 直接使用 make 创建一个channel，接受的数据类型是string ch := make(chan string) // 一个channel的操作只有两种： // - 发送，向chan中发送值： chan&amp;lt;- // - 接受，从chan中获取值： &amp;lt;-chan demo
func main(){  ch := make(chan string)  go func(){  fmt.</description>
    </item>
    
    <item>
      <title>5. go基础：通过 error/deffer/panic 处理错误</title>
      <link>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</guid>
      <description>正确处理错误，可以让程序更加稳定。error是一个错误接口，一般来说，error是不会影响到整个程序运行的，我们可以自行处理。 而panic是会导致程序直接崩溃退出的，我们也可以用 go自带的recover()来恢复panic，在程序崩溃前进行资源的释放工作。
错误 error接口 error接口只有一个Error方法，返回具体的错误信息（string）
type error interface {  Error() string } 一个字符串转整数的例子：
func main(){  // try to conver alpha &amp;#34;a&amp;#34; to integer  i, err := strconv.Atoi(&amp;#34;a&amp;#34;)  if err != nil {  fmt.Println(err)  } else {  fmt.Println(i)  } } 尝试将字符 a 转换成为 整数，显然是不成功的，因此返回了err
 一般而言，error 接口用于当方法或者函数执行遇到错误时进行返回，而且是第二个返回值。通过这种方式，可以让调用者自己根据错误信息决定如何进行下一步处理。
 error 工厂函数 除了可以使用其他函数，自己定义的函数也可以返回错误信息给调用者
自定义error 自定义error就是先自定义一个新的类型，然后实现error接口
// 自定义一个结构体，携带错误码和具体的错误信息 type commonError struct {  errorCode int	// 错误码  errorMsg string // 错误信息 }  // 实现error接口 func (ce *commonError) Error() string {  return ce.</description>
    </item>
    
    <item>
      <title>3. go基础：函数和方法</title>
      <link>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</guid>
      <description>函数和方法，大大提高了我们的代码复用率，也提高了代码的可读性。 go语言的函数和方法的定义十分简单，直接使用 func 关键字即可。
不同于python、C++等有类的概念，而这些类中，又有自己的方法，或者父类的方法。go语言中，我们可以定义一个数据结构，然后给这个数据结构实现自己的方法，同样可以实现【类】的效果，通过组合，同一个结构体中，也可以使用或者覆写其他结构体的方法。
函数 函数的组成：  关键字 func 函数名 funcName 参数 params 返回值（返回值类型） 函数体  func funcName(params) result { 	// body } // 示例1：普通的函数定义 func sum(a int, b int) int { 	return a + b } // 示例2：参数表的类型合并，(a int, b int) -&amp;gt; (a, b int) func sum2(a, b int) int { 	return a + b } // 示例3：多值返回，用 （） 包裹起来 func sum3(a, b int) (int, error) { 	if a &amp;lt; 0 || b &amp;lt; 0 { 	return 0, errors.</description>
    </item>
    
    <item>
      <title>4. go基础：结构体和接口</title>
      <link>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</guid>
      <description>接口是一种聚合类型，结构体是和调用方的一种约定，有点抽象类的意思。:)
结构体 结构体定义 结构体是一种聚合类型，里面可以包含任意类型的值，这些值就是我们定义的结构体成员，也称为字段
在go语言中，要定义一个结构体，需要使用 type+struct 关键字组合。
// 定义一个代表【人】的结构体 type person struct {  name string	// 名称  age uint	// 年龄 } 结构体的成员字段并不是必需的，也可以一个字段都没有，这种结构体成为空结构体。
type s struct {} 结构体声明使用 // 使用var声明一个person变量，未初始化，里面的值为各自变量的零值 var p person // 可以使用结构体字面量初始化的方式 p2 := person{&amp;#34;Mike&amp;#34;, 10} // 第一个值为 name，第二个值为age，与结构体字段定义顺序有关 // 可以指定字段名初始化，不按定义顺序 p3 := person{age: 10, name: &amp;#34;Mike&amp;#34;} 字段结构体 type address struct {  province string  city string } // 结构体的字段可以是任意类型，也可以是自定义的结构体 type person struct {  name string  age uint  addr address }  // 初始化 p := person{  name: &amp;#34;Mike&amp;#34;,  age: 10,  addr: address{  province: &amp;#34;Guandong&amp;#34;,  city: &amp;#34;Maoming&amp;#34;,  }, } fmt.</description>
    </item>
    
    <item>
      <title>2. go基础：使用array/slice/map</title>
      <link>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</guid>
      <description>数组，大概是每个变成语言都有基础数据结构。
Go的切片类型（slice）提供了一种方便和有效的方法来处理类型化数据序列（数组）。slice类似于其他语言中的数组，但有一些不同寻常的属性。
map可以理解为一个字典。
数组声明 可以使用 [长度]类型{} 来定义，比如 [2]string{}定义一个长度为2的字符串数组
这里的长度必须是一个常量，如果要使用变量去动态生成数组的话，需要使用make，如
make([]string, size) 这里的size是一个变变量，生成size长度的字符串数组
另外需要注意的是, [1]string 和 [2]string 不是用一种类型，长度也是数组类型的一部分
定义数组时可以省略数组的长度，此时会根据大括号{}里面的元素个数推到出数组的长度：
arr := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;} 这里会自动生成长度为5的字符串数组，适用于所有元素都被初始化的数据
但是如果只有特定元素被初始化的数组，就不合适了：
arr := [5]string{1: &amp;#34;a&amp;#34;, 3: &amp;#34;c&amp;#34;} 上述表示数组初始化索引为1的值为a，索引为3的值为c，其他未初始化的为空值（字符串的空值为&amp;quot;&amp;quot;）
如果我们不指定 [5]string，那么go就会根据我们定义的最大索引值3 来确定数组的长度为4
数组循环  使用传统的数组循环：  for i := 0; i &amp;lt; len(arr); i++ { 	fmt.Println(arr[i]) }  使用 for range 数组遍历，写法更加简洁  for index, value := range arr { 	fmt.Printf(&amp;#34;index = %v, value = %v\n&amp;#34;, index, value) } 切片 Slice 切片的区间是左闭右开，如arr[2:5]，选取的索引取数是[2,3,4] 切片的底层是（原）数组，将切片内容修改之后，原数组也会改变</description>
    </item>
    
    <item>
      <title>1. go基础：数据类型，以及控制结构</title>
      <link>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</guid>
      <description>go最近很火啊，自带高并发，内置网络模块强大，作为后端工程师一枚，自然也要学起来！
go 的基础部分跟我们之前学过的大部分语言是都是十分相似的，上手十分简单。
第一个go程序 第一个程序大都是hello嘛，向新世界打个招呼 :)
import fmt  func main(){  fmt.Println(&amp;#34;hello golang!&amp;#34;) } 数据类型以及变量声明的方式 变量声明的方式 // var 变量名 类型 = 表达式 var num int = 1 // 也可以声明变量，但是不赋值 var num int	// 这样的默认值就是int的默认值 0 // 可以直接赋值并且声明类型 num := 1 // 可以实现多值定义 a, b, c := 1, 2, &amp;#34;hello&amp;#34; var (  a = 1  b = 2  c = &amp;#34;hello&amp;#34; ) 常量声明 常量声明，我们可以直接使用 const 关键字，不需要指定数据的类型，通常，常量我们用大写进行命名
我们指定变量的值，会自定将变量转为对应的类型</description>
    </item>
    
  </channel>
</rss>
