<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go on Coding and Life</title>
    <link>https://zihuanling.github.io/tags/go/</link>
    <description>Recent content in go on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Apr 2022 22:34:33 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go: grpc和protobuf</title>
      <link>https://zihuanling.github.io/posts/go-grpc-protobuf/</link>
      <pubDate>Sat, 16 Apr 2022 22:34:33 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-grpc-protobuf/</guid>
      <description>gRPC 一个高性能、开源的通用RPC框架。
gPPC是一个现代的开源高性能的远程过程调用框架，并且可以运行在任何环境中。它可以有效地连接数据中心内和跨数据中心的服务，支持负载均衡、跟踪、健康检查和身份验证。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。
 gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.
 github 地址： https://github.com/grpc/grpc
原来是用 C++ 写的，后来也有了go语言版本：https://github.</description>
    </item>
    
    <item>
      <title>go 和 protobuf</title>
      <link>https://zihuanling.github.io/posts/go-proto/</link>
      <pubDate>Thu, 14 Apr 2022 21:14:52 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-proto/</guid>
      <description>Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。
 Protocol buffers are Google&amp;rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
 安装protoc编译器 .</description>
    </item>
    
    <item>
      <title>Go 使用mongodb</title>
      <link>https://zihuanling.github.io/posts/go-mongo/</link>
      <pubDate>Sun, 10 Apr 2022 16:06:40 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-mongo/</guid>
      <description>安装 mkdir go-mongo go mod init go-mongo go get go.mongodb.org/mongo-driver/mongo 使用 数据库里面有一条这样的数据：
{  &amp;#34;_id&amp;#34;: {  &amp;#34;$oid&amp;#34;: &amp;#34;6252912ec4495f97bccf41aa&amp;#34;  },  &amp;#34;title&amp;#34;: &amp;#34;My Mongo Post&amp;#34;,  &amp;#34;create_time&amp;#34;: {  &amp;#34;$date&amp;#34;: &amp;#34;2022-04-10T10:33:45.149Z&amp;#34;  },  &amp;#34;viewer&amp;#34;: 201 } 连接数据库 // 关键代码 const MONGO_URI = &amp;#34;mongodb://localhost:27017/test&amp;#34; client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(MONGO_URI))  // 优雅关闭连接 defer client.Disconnect(context.TODO()) 数据查询 首先获取到对应的database以及collection
coll := client.Database(&amp;#34;test&amp;#34;).Collection(&amp;#34;post&amp;#34;) 然后查询：
coll := client.Database(&amp;#34;test&amp;#34;).Collection(&amp;#34;post&amp;#34;) var result bson.M	// 需要一个bson.M 对象，用于存储查询回来的数据 // FindOne 接受2个参数，一个context，一个filter，filter 为 bson.</description>
    </item>
    
    <item>
      <title>go：简简单单的并发网络连接</title>
      <link>https://zihuanling.github.io/posts/go-concurrent-server/</link>
      <pubDate>Wed, 06 Apr 2022 20:45:19 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-concurrent-server/</guid>
      <description>go 是天生支持并发的，我们只要 使用 go func() 就可以快速实现并发。在网络服务的处理中，实现并发可以大大提高服务的吞吐量，我们来研究一下。
简单的TCP服务器 我们先来实现一个简单的tcp服务，监听8989端口，从连接中读取一段数据，这段数据表示的是当前请求的id，然后返回一段话。
服务器 server/main.go
package main  import ( 	&amp;#34;fmt&amp;#34; 	&amp;#34;log&amp;#34; 	&amp;#34;net&amp;#34; )  func main() { 	// 启动tcp连接，监听8989端口 	l, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;:8989&amp;#34;) 	if err != nil { 	log.Fatalf(&amp;#34;Server listening error: %s\n&amp;#34;, err) 	} 	for { 	conn, err := l.Accept() 	if err != nil { 	log.Printf(&amp;#34;Accept error: %s\n&amp;#34;, err) 	continue 	} 	// 接收连接,调用handleConn处理当前连接 	handleConn(conn) 	} }  func handleConn(conn net.</description>
    </item>
    
    <item>
      <title>Go：简单的跨平台rpc服务</title>
      <link>https://zihuanling.github.io/posts/go-rpc-server/</link>
      <pubDate>Wed, 30 Mar 2022 10:52:00 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-rpc-server/</guid>
      <description>RPC RPC - Remote Procedure Call 称为远程过程调用，是分布式系统中，不同节点调用的方式（进程间通信），属于 C/S 模式。由客户端发起，调用服务端的方法进行通信，服务端将结果返回给客户端。
RPC的两个核心：
 通信协议 序列化  序列化和反序列化是一种把传输内容编码和解码的方式，常见的编解码方式有 JSON、Protobuf 等。
大多数 RPC 架构中，都有 Client、Client Stub、Server、Server Stub这四个组件，Client 和 Server 通过 Socket 进行通信。
flowchart LR subgraph 服务端进程 s(Server) ss(Server Stub) s --调用--&amp;gt; ss ss --返回--&amp;gt; s end subgraph 客户端进程 c(Client) cs(Client Stub) c --调用--&amp;gt; cs cs --返回--&amp;gt; c end 客户端进程 ==网络消息==&amp;gt; 服务端进程 服务端进程 ==&amp;gt; 客户端进程 调用流程：
 client 调用 client stub，同时把参数传给 client stub client stub将参数打包编码，然后通过系统调用发送到服务端进程 客户端本地系统发送信息到服务器 服务器系统将信息发送到 server stub server stub 将信息解码 server stub 调用真正的服务端程序 server server 处理后，通过同样的方式，将结果返回到 client  go 实现简单的RPC服务 go内置了 net/rpc 包帮助我们实现rpc服务。</description>
    </item>
    
    <item>
      <title>Go：简单的http服务以及Restful Api</title>
      <link>https://zihuanling.github.io/posts/go-http-server/</link>
      <pubDate>Sun, 27 Mar 2022 15:27:00 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-http-server/</guid>
      <description>简易 http 服务 使用 go 自带的 http 模块实现一个简单的 http 服务器，对请求者说一句 Hello, go http!
func main(){ 	http.HandleFunc(&amp;#34;/hello&amp;#34;, sayHello) 	http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) }  func sayHello(resp http.ResponseWriter, req *http.Request) { 	log.Println(&amp;#34;In say hello&amp;#34;) 	resp.WriteHeader(http.StatusOK) 	resp.Write([]byte(&amp;#34;Hello, go http!&amp;#34;)) } 运行上述代码，在终端使用 curl 访问该地址，返回正常：
&amp;gt;curl http://localhost:8080/hello Hello, go http! 且程序使用 log 打印了一句： 2022/03/27 15:32:48 In say hello
但是，我们的http方法有很多， GET/POST/PUT/PATCH/DELETE 等，我们使用任意一个方法，访问上述地址，都能得到 Hello, go http! 这句返回，如 POST:
&amp;gt;curl -X POST http://localhost:8080/hello Hello, go http!</description>
    </item>
    
    <item>
      <title>17.go: 代码检查和性能优化</title>
      <link>https://zihuanling.github.io/posts/go-17-quarlity-and-optimization/</link>
      <pubDate>Sat, 26 Mar 2022 20:01:10 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-17-quarlity-and-optimization/</guid>
      <description>对我们的代码进行检查，有助于提高代码质量，确保代码更加符合规范。
使用 golangci-lint 进行代码检查 go语言代码分析的工具有很多，如 golint、gofmt、misspell等，我们一般使用 集成工具 golangci-lint，而不是单独使用他们。
安装 go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.32.2 查看版本 golangci-lint version 输出：
golangci-lint has version v1.32.2 ... 运行检查： golangci-lint run quality/ 这里的 quality是一个包，里面有一个 main.go 文件，内容如下：
quality/main.go
package main  import &amp;#34;os&amp;#34;  func main(){ 	os.Mkdir(&amp;#34;/tmp&amp;#34;, 0666) } 运行检查后，输出如下：
quality\main.go:6:10: Error return value of `os.Mkdir` is not checked (errcheck) os.Mkdir(&amp;#34;/tmp&amp;#34;, 0666) 因为 os.Mkdir 返回一个 error，但是我们没有处理这个 error，因此提示了这个错误。
golangci-lint 配置 golangci-lint是一个集成工具，里面有很多linters，我们可以用 golangci-lint linters 查看有哪些linters，以及他们的作用、启用情况，默认启用的linters如下：
deadcode - 死代码检查 errcheck - 返回错误是否使用检查 gosimple - 检查代码是否可以简化 govet - 代码可疑检查，比如格式化字符串和类型不一致 ineffassign - 检查是否有未使用的代码 staticcheck - 静态分析检查 structcheck - 查找未使用的结构体字段 typecheck - 类型检查 unused - 未使用代码检查 varcheck - 未使用的全局变量和常量检查 我们可以通过一个 .</description>
    </item>
    
    <item>
      <title>16.go: 单元测试和基准测试</title>
      <link>https://zihuanling.github.io/posts/go-16-test-1/</link>
      <pubDate>Mon, 21 Mar 2022 22:23:25 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-16-test-1/</guid>
      <description>单元测试 单元测试就是对单元进行测试（听起来是一句废话），单元可以是一个函数、一个模块等，我们最小的单元是一个函数。
以斐波那契数列为例，实现一个测试用例
test/main.go
package main  // 斐波那契数列 func Fibonacci(n int) int { 	if n &amp;lt;= 0 { 	return 0 	} else if n == 1 { 	return 1 	} 	return Fibonacci(n-1) + Fibonacci(n-2) } 我们在 main.go 里面写了一个 Fibonacci函数，用于计算对应的斐波那契值。
我们接下来写一个测试用例，测试的文件名应该是以 _test.go 结尾的，前面的名称最好是需要测试的文件名称，比如要测试 main.go，则测试文件命名为 main_test.go，而在 测试文件里面，需要一个以 Test开头的函数，后面接需要测试的函数名称，如 TestFibonacci，这个函数接受一个 *Testing.T指针，且不返回任何值
test/main_test.go
func TestFibonacci(t *testing.T) { 	result := map[int]int{ 	1: 1, 2: 1, 3: 2, 4: 3, 5: 5, 	6: 8, 7: 13, 8: 21, 	} 	for n, expect := range result { 	got := Fibonacci(n) 	if expect !</description>
    </item>
    
    <item>
      <title>15.go深入：SliceHeader，高效的slice</title>
      <link>https://zihuanling.github.io/posts/go-15-depth-slice-header/</link>
      <pubDate>Fri, 18 Mar 2022 14:34:12 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-15-depth-slice-header/</guid>
      <description>数组 数组由两部分组成：数组的大小和数组内部的元素类型。
// 伪代码表示 array {  len  item type } 看以下两个数组的定义：
a1 := [1]string{&amp;#34;mike&amp;#34;} a2 := [2]string{&amp;#34;mike&amp;#34;} 上述定义的两个变量，a1的类型为 [1]string，a2的类型为 [2]string，所以说，数组的大小也属于数组类型的一部分。
数组的两个限制   **一旦一个数组被声明，它的大小和内部的类型就不能改变，**我们将不能随意向其中追加任意多的元素。
  另外，当我们使用数组存储大量数据，然后将数组作为函数的参数进行传值时，由于函数之间是值传递的，因此，数组的拷贝将会耗费巨大的内存。
  slice 切片 我们可以将切片理解为动态的数组。
切片是对数组的封装，它的底层是一个数组存储了所有的元素，但是它可以动态地添加元素，容量不足时可以自动扩容。
动态扩容 使用内置的append方法，向切片中追加元素，返回一个新的切片。
同时，当容量不足的时候，append会自动对切片进行扩容。
func main(){  ss := []string{&amp;#34;mike&amp;#34;} // 定义切片ss  fmt.Printf(&amp;#34;slice before append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss))  ss = append(ss, &amp;#34;lucy&amp;#34;, &amp;#34;john&amp;#34;) // append 追加元素  fmt.Printf(&amp;#34;slice after append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss)) } 输出：</description>
    </item>
    
    <item>
      <title>12.go深入：new、make和内存分配</title>
      <link>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</link>
      <pubDate>Sun, 13 Mar 2022 23:35:38 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</guid>
      <description>Go语言程序所管理的虚拟内存空间会被分为两部分：堆内存和栈内存。栈内存主要由Go语言来管理，开发者无法干涉太多，堆内存则有开发者进行分配。
变量 一个数据类型，在声明之后，会被赋值给一个变量，变量存储了程序所需的数据。
变量的声明 单纯的声明变量，可以使用var关键字，如：
var s string	// 声明一个[字符串]变量，初始值为零值&amp;#34;&amp;#34; var sp *string	// 声明一个[字符串指针]变量，初始值为 nil 变量的初始化 有3种方法
 声明的时候直接初始化： var name string = &amp;quot;mike&amp;quot; 声明之后再进行赋值初始化： name = &amp;quot;mike&amp;quot;,此前 name 变量已经声明 直接使用 := 进行初始化： name := &amp;quot;mike&amp;quot;  值变量和指针变量初始化的区别 我们使用值初始化的时候，可以简单的这样写：
var name string name = &amp;#34;mike&amp;#34; 但是，当我们使用指针初始化的时候：
var nameP *string // 声明一个字符串指针 *nameP = &amp;#34;mike&amp;#34;	// 给nameP指向的地址赋值初始化 这时候，由于 nameP 指向的是一个空地址 nil，我们对这个空地址进行赋值初始化的时候，会报以下错误：
panic: runtime error: invalid memory address or nil pointer dereference 显而易见，我们无法对一个空地址赋值。</description>
    </item>
    
    <item>
      <title>10. go深入：Go 中的指针</title>
      <link>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</guid>
      <description>什么是指针 可以简单将指针理解为内存地址。
指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象，可以是整型、字符串、或者是我们自定义的任意结构体类型。
也可以理解为：指针就是一本书上的目录上面的页码，这个页码指向具体的内容。
指针的声明和定义 以字符串指针为例
// 声明一个字符串指针变量 var sp *string // 直接通过 &amp;amp; 操作符获取一个字符串的地址 s := &amp;#34;Hello world.&amp;#34; sp := &amp;amp;s // 还可以使用 new 函数，传入一个类型作为参数，用以返回该类型的指针 sp := new(string) 指针的操作 针对指针的操作，有两种：获取或者修改指针指向的值
 获取指针指向的值  使用 *指针变量 获取指针指向的值，如 *sp 获取sp指针指向的内存地址的值。
修改指针指向的值  修改跟获取值也是类似的，使用 *指针变量 = 值 来修改，如 *sp = &amp;quot;new value&amp;quot;，这样，就把 sp指针指向的内存地址值修改为了 new value
注意 另外，通过 var sp *string 定义的sp指针，初始值是nil，表示它没有指向任何一块内存地址，我们不能够对它进行取值和赋值操作，否则，会提示：
invalid memory address or nil pointer dereference
要解决这个问题，只需要使用 new 函数给该地址分配一块内存即可：
var sp *string = new(string)</description>
    </item>
    
    <item>
      <title>9. go并发：Go 中的并发模式</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</guid>
      <description>for select 模式 这是一种常见的并发模式，我们一般使用 for {}  死循环，然后里面加select配合channel，获取协程的终止信号，来控制协程的退出
for {  select {  case &amp;lt;- done:  // received stop signal, stopping.  return  default: 	// processing ...  } } 类似的还有 for range select模式，主要就是使用 for ... range 遍历某个数据数组，将数据发送到channel里面：
for _, value := range []int{} {  select {  case &amp;lt;- done:  // 接受到终止信号  return  case resultCh &amp;lt;- value:  // do nothing but put value to rsult channel  } } select timeout 模式 select timeout模式，核心在于使用 time.</description>
    </item>
    
    <item>
      <title>8. go并发：Context-多线程并发控制神器</title>
      <link>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</guid>
      <description>协程如何退出 一般来说，我们执行协程，需要等到协程执行完毕，才能够退出。但是，当我们想要让协程提前退出，就需要一种机制，去控制协程的退出。
以下例子使用select + channel的方式，控制协程的退出
 func main() { 	ch := make(chan bool) 	var wg sync.WaitGroup 	go func() { 	defer wg.Done()  // 开启looper协程 	looper(ch) 	}() 	wg.Add(1)  // 5秒后发送中断信号 	time.Sleep(time.Second * 5) 	fmt.Println(&amp;#34;Signal to goroutine exit...&amp;#34;) 	ch &amp;lt;- true 	fmt.Println(&amp;#34;Signal sent.&amp;#34;) 	wg.Wait() // 等待协程完全退出 	fmt.Println(&amp;#34;Exit.&amp;#34;) }  func looper(ch &amp;lt;-chan bool){ 	for { 	select { 	case &amp;lt;-ch: 	fmt.</description>
    </item>
    
    <item>
      <title>7. go并发：同步原语，用sync包控制并发</title>
      <link>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</guid>
      <description>go在并发的时候，可能会出现多个协程同时访问一个资源的时候，这就出现了资源竞争。也可能出现协程还在运行，但是主程序却退出了的情况，这是缺少控制导致的。
用sync包，可以方便的控制资源的访问，也可以方便实现阻塞等待，让协程执行完毕再退出程序，或者执行下一步。
资源竞争 在同一个goroutine中，如果分配的内存没有被其他的goroutine访问，只在该goroutine中使用，则不存在资源竞争问题
如果同一块内存被多个goroutine同时访问，就会产生不知道谁先访问，也无法预料最后结果的情况，这就是资源竞争：
// 共享的资源 var sum = 0 func main(){  for i := 0; i &amp;lt; 100; i++ {  go add(10)  }  // goroutine 不会阻塞下面的代码，此处Sleep一下，防止main goroutine直接退出  // 而导致未完成的goroutine也被终止  time.Sleep(time.Second * 2)  fmt.Println(&amp;#34;Sum is:&amp;#34;, sum) }  func add(i int) {  sum += i } 上述例子中，sum变量为共享的资源，程序运行的过程中会发生资源竞争。
 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争
 同步原语 sync.</description>
    </item>
    
    <item>
      <title>6. go并发：Goroutines和Channels的声明和使用</title>
      <link>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</guid>
      <description>并发，就是让程序在同一时刻做多件事情。
go语言天生自带并发属性，使得并发编程十！分！方！便！，我们只需要 go 函数名() 即可！\(^o^)/
进程和线程 进程 程序启动时，系统会为其创建一个进程
线程 是进程的执行空间，一个进程可以包含多个线程，线程被操作系统调度执行 一个程序启动，对应的进程会被创建，同时也会创建一个线程（主线程），主线程结束，整个程序也就退出了。 我们可以从主线程创建其他的子线程，这就是多线程并发
协程 Goroutine goroutine比线程更加轻盈，被Go runtime调度。 启动协程： go function()
// 这里启动了两个goroutine， 一个是用go关键字触发的，另一个是 main goroutine（主线程） func main(){  go fmt.Println(&amp;#34;Hello goroutine.&amp;#34;)  fmt.Println(&amp;#34;Main goroutine.&amp;#34;)  time.Sleep(time.Second) } Channel 多个goroutine之间，使用 channel进行通信
声明一个channel // 直接使用 make 创建一个channel，接受的数据类型是string ch := make(chan string) // 一个channel的操作只有两种： // - 发送，向chan中发送值： chan&amp;lt;- // - 接受，从chan中获取值： &amp;lt;-chan demo
func main(){  ch := make(chan string)  go func(){  fmt.</description>
    </item>
    
    <item>
      <title>5. go基础：通过 error/deffer/panic 处理错误</title>
      <link>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</guid>
      <description>正确处理错误，可以让程序更加稳定。error是一个错误接口，一般来说，error是不会影响到整个程序运行的，我们可以自行处理。 而panic是会导致程序直接崩溃退出的，我们也可以用 go自带的recover()来恢复panic，在程序崩溃前进行资源的释放工作。
错误 error接口 error接口只有一个Error方法，返回具体的错误信息（string）
type error interface {  Error() string } 一个字符串转整数的例子：
func main(){  // try to conver alpha &amp;#34;a&amp;#34; to integer  i, err := strconv.Atoi(&amp;#34;a&amp;#34;)  if err != nil {  fmt.Println(err)  } else {  fmt.Println(i)  } } 尝试将字符 a 转换成为 整数，显然是不成功的，因此返回了err
 一般而言，error 接口用于当方法或者函数执行遇到错误时进行返回，而且是第二个返回值。通过这种方式，可以让调用者自己根据错误信息决定如何进行下一步处理。
 error 工厂函数 除了可以使用其他函数，自己定义的函数也可以返回错误信息给调用者
自定义error 自定义error就是先自定义一个新的类型，然后实现error接口
// 自定义一个结构体，携带错误码和具体的错误信息 type commonError struct {  errorCode int	// 错误码  errorMsg string // 错误信息 }  // 实现error接口 func (ce *commonError) Error() string {  return ce.</description>
    </item>
    
    <item>
      <title>3. go基础：函数和方法</title>
      <link>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</guid>
      <description>函数和方法，大大提高了我们的代码复用率，也提高了代码的可读性。 go语言的函数和方法的定义十分简单，直接使用 func 关键字即可。
不同于python、C++等有类的概念，而这些类中，又有自己的方法，或者父类的方法。go语言中，我们可以定义一个数据结构，然后给这个数据结构实现自己的方法，同样可以实现【类】的效果，通过组合，同一个结构体中，也可以使用或者覆写其他结构体的方法。
函数 函数的组成：  关键字 func 函数名 funcName 参数 params 返回值（返回值类型） 函数体  func funcName(params) result { 	// body } // 示例1：普通的函数定义 func sum(a int, b int) int { 	return a + b } // 示例2：参数表的类型合并，(a int, b int) -&amp;gt; (a, b int) func sum2(a, b int) int { 	return a + b } // 示例3：多值返回，用 （） 包裹起来 func sum3(a, b int) (int, error) { 	if a &amp;lt; 0 || b &amp;lt; 0 { 	return 0, errors.</description>
    </item>
    
    <item>
      <title>4. go基础：结构体和接口</title>
      <link>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</guid>
      <description>接口是一种聚合类型，结构体是和调用方的一种约定，有点抽象类的意思。:)
结构体 结构体定义 结构体是一种聚合类型，里面可以包含任意类型的值，这些值就是我们定义的结构体成员，也称为字段
在go语言中，要定义一个结构体，需要使用 type+struct 关键字组合。
// 定义一个代表【人】的结构体 type person struct {  name string	// 名称  age uint	// 年龄 } 结构体的成员字段并不是必需的，也可以一个字段都没有，这种结构体成为空结构体。
type s struct {} 结构体声明使用 // 使用var声明一个person变量，未初始化，里面的值为各自变量的零值 var p person // 可以使用结构体字面量初始化的方式 p2 := person{&amp;#34;Mike&amp;#34;, 10} // 第一个值为 name，第二个值为age，与结构体字段定义顺序有关 // 可以指定字段名初始化，不按定义顺序 p3 := person{age: 10, name: &amp;#34;Mike&amp;#34;} 字段结构体 type address struct {  province string  city string } // 结构体的字段可以是任意类型，也可以是自定义的结构体 type person struct {  name string  age uint  addr address }  // 初始化 p := person{  name: &amp;#34;Mike&amp;#34;,  age: 10,  addr: address{  province: &amp;#34;Guandong&amp;#34;,  city: &amp;#34;Maoming&amp;#34;,  }, } fmt.</description>
    </item>
    
    <item>
      <title>2. go基础：使用array/slice/map</title>
      <link>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</guid>
      <description>数组，大概是每个变成语言都有基础数据结构。
Go的切片类型（slice）提供了一种方便和有效的方法来处理类型化数据序列（数组）。slice类似于其他语言中的数组，但有一些不同寻常的属性。
map可以理解为一个字典。
数组声明 可以使用 [长度]类型{} 来定义，比如 [2]string{}定义一个长度为2的字符串数组
这里的长度必须是一个常量，如果要使用变量去动态生成数组的话，需要使用make，如
make([]string, size) 这里的size是一个变变量，生成size长度的字符串数组
另外需要注意的是, [1]string 和 [2]string 不是用一种类型，长度也是数组类型的一部分
定义数组时可以省略数组的长度，此时会根据大括号{}里面的元素个数推到出数组的长度：
arr := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;} 这里会自动生成长度为5的字符串数组，适用于所有元素都被初始化的数据
但是如果只有特定元素被初始化的数组，就不合适了：
arr := [5]string{1: &amp;#34;a&amp;#34;, 3: &amp;#34;c&amp;#34;} 上述表示数组初始化索引为1的值为a，索引为3的值为c，其他未初始化的为空值（字符串的空值为&amp;quot;&amp;quot;）
如果我们不指定 [5]string，那么go就会根据我们定义的最大索引值3 来确定数组的长度为4
数组循环  使用传统的数组循环：  for i := 0; i &amp;lt; len(arr); i++ { 	fmt.Println(arr[i]) }  使用 for range 数组遍历，写法更加简洁  for index, value := range arr { 	fmt.Printf(&amp;#34;index = %v, value = %v\n&amp;#34;, index, value) } 切片 Slice 切片的区间是左闭右开，如arr[2:5]，选取的索引取数是[2,3,4] 切片的底层是（原）数组，将切片内容修改之后，原数组也会改变</description>
    </item>
    
    <item>
      <title>1. go基础：数据类型，以及控制结构</title>
      <link>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</guid>
      <description>go最近很火啊，自带高并发，内置网络模块强大，作为后端工程师一枚，自然也要学起来！
go 的基础部分跟我们之前学过的大部分语言是都是十分相似的，上手十分简单。
第一个go程序 第一个程序大都是hello嘛，向新世界打个招呼 :)
import fmt  func main(){  fmt.Println(&amp;#34;hello golang!&amp;#34;) } 数据类型以及变量声明的方式 变量声明的方式 // var 变量名 类型 = 表达式 var num int = 1 // 也可以声明变量，但是不赋值 var num int	// 这样的默认值就是int的默认值 0 // 可以直接赋值并且声明类型 num := 1 // 可以实现多值定义 a, b, c := 1, 2, &amp;#34;hello&amp;#34; var (  a = 1  b = 2  c = &amp;#34;hello&amp;#34; ) 常量声明 常量声明，我们可以直接使用 const 关键字，不需要指定数据的类型，通常，常量我们用大写进行命名
我们指定变量的值，会自定将变量转为对应的类型</description>
    </item>
    
  </channel>
</rss>
