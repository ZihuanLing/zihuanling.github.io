<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go 和 protobuf | Coding and Life</title><meta name=keywords content="go,protobuf"><meta name=description content="Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。
Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
安装protoc编译器 .proto文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。
因此，我们使用特定的编程语言编写服务时，需要将我们定义的 ."><meta name=author content="LingZihuan"><link rel=canonical href=https://zihuanling.github.io/posts/go-proto/><meta name=google-site-verification content="G-FEL07ZZK1M"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/favicon.ico as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zihuanling.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zihuanling.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zihuanling.github.io/favicon.ico><link rel=apple-touch-icon href=https://zihuanling.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zihuanling.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.staticfile.org/mermaid/9.0.1/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?57e5cca974e7e653044600798423acf5",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FEL07ZZK1M"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FEL07ZZK1M",{anonymize_ip:!1})}</script><meta property="og:title" content="go 和 protobuf"><meta property="og:description" content="Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。
Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
安装protoc编译器 .proto文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。
因此，我们使用特定的编程语言编写服务时，需要将我们定义的 ."><meta property="og:type" content="article"><meta property="og:url" content="https://zihuanling.github.io/posts/go-proto/"><meta property="og:image" content="https://zihuanling.github.io/avatar.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-14T21:14:52+08:00"><meta property="article:modified_time" content="2022-04-14T21:14:52+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zihuanling.github.io/avatar.jpeg"><meta name=twitter:title content="go 和 protobuf"><meta name=twitter:description content="Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。
Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
安装protoc编译器 .proto文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。
因此，我们使用特定的编程语言编写服务时，需要将我们定义的 ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zihuanling.github.io/posts/"},{"@type":"ListItem","position":2,"name":"go 和 protobuf","item":"https://zihuanling.github.io/posts/go-proto/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 和 protobuf","name":"go 和 protobuf","description":"Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。\nProtocol buffers are Google\u0026rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.\n安装protoc编译器 .proto文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。\n因此，我们使用特定的编程语言编写服务时，需要将我们定义的 .","keywords":["go","protobuf"],"articleBody":"Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。\nProtocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.\n安装protoc编译器 .proto文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。\n因此，我们使用特定的编程语言编写服务时，需要将我们定义的 .proto 文件翻译（编译）成为对应的语言文件，这时，google 给我们提供了 protoc。\n下载 我们可以在这个地方下载： protobuf v3.20.0 ，里面有很多的版本，我们可以找到对应的平台。\n安装 将其解压之后，我们得到一个 bin目录，里面有一个 protoc的可执行文件，我们将其添加到环境变量中的Path中去，这样，我们就可以在终端中运行protoc命令了。\n验证安装 我们添加完环境变量后，打开一个新的终端，我们输入以下命令来验证一下安装是否成功：\n\u003eprotoc --version libprotoc 3.20.0 编写自己的protobuf协议 我想要实现一个协议，可以传输多媒体数据，且后端是用go写的。\n首先创建一个项目，名为 learnProto，表示这是我用来学习protobuf的练手项目。然后创建一个proto文件夹，用来存放我们的proto文件。\n// learnProto/proto/media.proto syntax = \"proto3\"; message Picture { string name = 1; // 图片的名称 enum PicTypes { PNG = 0; JPG = 1; JPEG = 2; BMQ = 3; } PicTypes type = 2; // 图片类型 bytes data = 3; // 图片数据 } 首先我们需要在文件的开始位置，写上 syntax = \"proto3\"，说明这个proto是用的proto3版本。\n上述proto文件中，我们定义了一个消息的结构：图片\n这个消息的结构有3个字段：\n名称：使用的是string类型 类型：我们自定义了一个枚举类型，用来表示允许进行传输的图片格式 数据：图片的数据应该是字节类型的 这样，我们就写好了自己的proto协议，我们将要使用这个协议来进行图片文件的传输。\n编译协议 **重要：**我们需要使用go来实现后端，然后使用编写的proto来实现数据的传输，这样，我们就需要给proto文件加上两行声明：\n第一行：告诉protoc编译器，这个proto文件编译成go文件之后，将要属于哪个包： package proto 第二行：告诉protoc编译器，这个proto文件当前的位置： option go_package=\"learnProto/proto\" proto文件改成了：\nsyntax = \"proto3\"; package proto; option go_package=\"learnProto/proto\"; // ... 省略 目前，我们的项目结构是长这样的：\nlearnProto/ proto/ media.proto go.mod 接下来我们使用protoc进行编译：\nprotoc --proto_path=. --go_out=. --go_opt=paths=source_relative proto/media.proto 命令运行之后，将会在 proto 文件夹下生成一个 media.pb.go 的文件，这个，就是我们通过 protoc 将 proto文件编译成的go文件。\n使用protobuf 编写go服务端 // learnProto/server/server_main.go package main import ( bf \"google.golang.org/protobuf/proto\" \"learnProto/proto\" \"log\" \"net\" ) func main() { l, _ := net.Listen(\"tcp\", \":8099\") for { conn, _ := l.Accept() log.Println(\"Received on connection.\") // read all from connection _data := make([]byte, 1024) if n, err := conn.Read(_data); err != nil { log.Fatalf(\"Read error: %s\", err) } else { log.Printf(\"%d bytes read\\n\", n) } message := \u0026proto.Picture{} bf.Unmarshal(_data, message) log.Printf(\"data: %v\", message) } } 服务端的代码简单，我们定义一个TCP服务端，监听8099端口，从里面获取数据，通过proto将其转化成为对应的结构体。\n由于是简单的使用proto，我们暂时不考虑里面传输的数据长度，直接构建一个1024长度的byte切片，从连接里面读取数据。然后使用 bf.Unmarshal 将里面的字节码数据反序列化为 proto.Picture结构体\n后续可以优化这块，比如约定开始传送的是一个长度为 HEADER_SIZE 的数据，里面声明了我们本次传输的内容是图片还是视频，然后接下来的数据有多大，等。\n编写go客户端 // learnProto/client/client_main.go package main import ( bf \"google.golang.org/protobuf/proto\" \"learnProto/proto\" \"log\" \"net\" \"time\" ) func main() { conn, _ := net.Dial(\"tcp\", \"localhost:8099\") message := \u0026proto.Picture{ Name: \"pandas\", Type: proto.Picture_JPG, Data: []byte{1, 2, 3, 4, 5, 6, 7}, } msg, _ := bf.Marshal(message) n, err := conn.Write(msg) if err != nil { log.Fatalf(\"Error write to connectin: %s\", err) } log.Printf(\"%d bytes wrote.\", n) time.Sleep(time.Second) } 客户端，我们使用 net.Dial 向服务端发起连接，然后构造一个假的 Picture消息，图片的名称为 pandas，图片的类型是 JPG，然后内容是随便给几个字节。\n然后，使用 bf.Marshal，将结构体数据序列化成为字节 []byte,通过tcp连接发送到客户端。\n随后休眠一秒，防止连接提前终端而导致服务端数据读取失败。\n运行 运行上述代码\n客户端输出：\n2022/04/14 23:42:00 19 bytes wrote. 服务端输出：\n2022/04/14 23:42:00 Received on connection. 2022/04/14 23:42:00 19 bytes read 2022/04/14 23:42:00 data: name:\"pandas\" type:JPG data:\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\" 可以看到，服务端收到了客户端发送的message，并且正确地将其序列化成为了 proto.Picture对象。\n改进 服务端可做改进： 考虑新增消息类型的时候，可以通过使用约定 HEADER 的方式，来确定接下来发送的消息属于什么类型，以及消息的长度等。\n接收到媒体信息的时候，将数据保存起来。\n使用 goroutine改造，支持并发处理多个请求。\n客户端可做改进： 图片的数据可以直接从文件或者数据库读取\n自动解析图片的名称、格式等\n","wordCount":"375","inLanguage":"en","datePublished":"2022-04-14T21:14:52+08:00","dateModified":"2022-04-14T21:14:52+08:00","author":{"@type":"Person","name":"LingZihuan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zihuanling.github.io/posts/go-proto/"},"publisher":{"@type":"Organization","name":"Coding and Life","logo":{"@type":"ImageObject","url":"https://zihuanling.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zihuanling.github.io/ accesskey=h title="Coding and Life (Alt + H)"><img src=https://zihuanling.github.io/favicon.ico alt=logo aria-label=logo height=35>Coding and Life</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zihuanling.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zihuanling.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zihuanling.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zihuanling.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zihuanling.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zihuanling.github.io/posts/>Posts</a></div><h1 class=post-title>go 和 protobuf</h1><div class=post-meta><span title='2022-04-14 21:14:52 +0800 +0800'>April 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;LingZihuan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#google-protocol-buffers aria-label="Google protocol buffers">Google protocol buffers</a></li><li><a href=#%e5%ae%89%e8%a3%85protoc%e7%bc%96%e8%af%91%e5%99%a8 aria-label=安装protoc编译器>安装protoc编译器</a><ul><ul><li><a href=#%e4%b8%8b%e8%bd%bd aria-label=下载>下载</a></li><li><a href=#%e5%ae%89%e8%a3%85 aria-label=安装>安装</a></li><li><a href=#%e9%aa%8c%e8%af%81%e5%ae%89%e8%a3%85 aria-label=验证安装>验证安装</a></li></ul></ul></li><li><a href=#%e7%bc%96%e5%86%99%e8%87%aa%e5%b7%b1%e7%9a%84protobuf%e5%8d%8f%e8%ae%ae aria-label=编写自己的protobuf协议>编写自己的protobuf协议</a><ul><li><a href=#%e7%bc%96%e8%af%91%e5%8d%8f%e8%ae%ae aria-label=编译协议>编译协议</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8protobuf aria-label=使用protobuf>使用protobuf</a><ul><li><a href=#%e7%bc%96%e5%86%99go%e6%9c%8d%e5%8a%a1%e7%ab%af aria-label=编写go服务端>编写go服务端</a></li><li><a href=#%e7%bc%96%e5%86%99go%e5%ae%a2%e6%88%b7%e7%ab%af aria-label=编写go客户端>编写go客户端</a></li><li><a href=#%e8%bf%90%e8%a1%8c aria-label=运行>运行</a></li><li><a href=#%e6%94%b9%e8%bf%9b aria-label=改进>改进</a><ul><li><a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%8f%af%e5%81%9a%e6%94%b9%e8%bf%9b aria-label=服务端可做改进：>服务端可做改进：</a></li><li><a href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8f%af%e5%81%9a%e6%94%b9%e8%bf%9b aria-label=客户端可做改进：>客户端可做改进：</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=google-protocol-buffers>Google protocol buffers<a hidden class=anchor aria-hidden=true href=#google-protocol-buffers>#</a></h1><p>简称<code>protobuf</code>，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像<strong>XML</strong>，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 <code>.proto</code> 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。</p><blockquote><p>Protocol buffers are Google&rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><h1 id=安装protoc编译器>安装protoc编译器<a hidden class=anchor aria-hidden=true href=#安装protoc编译器>#</a></h1><p><code>.proto</code>文件只是我们定义的协议文件，一般来讲，编程语言是不能直接使用这份文件的（除非是自己针对proto写一个自定义的解析逻辑，但是没人会这么闲），我们想要的，应该是简单高效的开发，可以即写即用那种。</p><p>因此，我们使用特定的编程语言编写服务时，需要将我们定义的 <code>.proto</code> 文件翻译（编译）成为对应的语言文件，这时，google 给我们提供了 protoc。</p><h3 id=下载>下载<a hidden class=anchor aria-hidden=true href=#下载>#</a></h3><p>我们可以在这个地方下载： <a href=https://github.com/protocolbuffers/protobuf/releases/tag/v3.20.0>protobuf v3.20.0</a> ，里面有很多的版本，我们可以找到对应的平台。</p><h3 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h3><p>将其解压之后，我们得到一个 <code>bin</code>目录，里面有一个 <code>protoc</code>的可执行文件，我们将其添加到环境变量中的<code>Path</code>中去，这样，我们就可以在终端中运行<code>protoc</code>命令了。</p><h3 id=验证安装>验证安装<a hidden class=anchor aria-hidden=true href=#验证安装>#</a></h3><p>我们添加完环境变量后，打开一个新的终端，我们输入以下命令来验证一下安装是否成功：</p><pre tabindex=0><code>&gt;protoc --version
libprotoc 3.20.0
</code></pre><h1 id=编写自己的protobuf协议>编写自己的protobuf协议<a hidden class=anchor aria-hidden=true href=#编写自己的protobuf协议>#</a></h1><p>我想要实现一个协议，可以传输多媒体数据，且后端是用go写的。</p><p>首先创建一个项目，名为 <code>learnProto</code>，表示这是我用来学习<code>protobuf</code>的练手项目。然后创建一个<code>proto</code>文件夹，用来存放我们的<code>proto</code>文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#75715e>// learnProto/proto/media.proto
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Picture</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 图片的名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>enum</span> PicTypes {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    PNG <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    JPG <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    JPEG <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    BMQ <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  PicTypes type <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// 图片类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bytes</span> data <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;     <span style=color:#75715e>// 图片数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>首先我们需要在文件的开始位置，写上 <code>syntax = "proto3"</code>，说明这个proto是用的proto3版本。</p><p>上述proto文件中，我们定义了一个消息的结构：图片</p><p>这个消息的结构有3个字段：</p><ul><li>名称：使用的是string类型</li><li>类型：我们自定义了一个枚举类型，用来表示允许进行传输的图片格式</li><li>数据：图片的数据应该是字节类型的</li></ul><p>这样，我们就写好了自己的proto协议，我们将要使用这个协议来进行图片文件的传输。</p><h2 id=编译协议>编译协议<a hidden class=anchor aria-hidden=true href=#编译协议>#</a></h2><p>**重要：**我们需要使用go来实现后端，然后使用编写的proto来实现数据的传输，这样，我们就需要给proto文件加上两行声明：</p><ul><li>第一行：告诉protoc编译器，这个proto文件编译成go文件之后，将要属于哪个包： <code>package proto</code></li><li>第二行：告诉protoc编译器，这个proto文件当前的位置： <code>option go_package="learnProto/proto"</code></li></ul><p>proto文件改成了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> proto;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> go_package<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;learnProto/proto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// ... 省略 
</span></span></span></code></pre></div><p>目前，我们的项目结构是长这样的：</p><pre tabindex=0><code>learnProto/
  proto/
    media.proto
  go.mod
</code></pre><p>接下来我们使用<strong>protoc</strong>进行编译：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>protoc --proto_path<span style=color:#f92672>=</span>. --go_out<span style=color:#f92672>=</span>. --go_opt<span style=color:#f92672>=</span>paths<span style=color:#f92672>=</span>source_relative proto/media.proto
</span></span></code></pre></div><p>命令运行之后，将会在 proto 文件夹下生成一个 <code>media.pb.go</code> 的文件，这个，就是我们通过 protoc 将 proto文件编译成的go文件。</p><h1 id=使用protobuf>使用protobuf<a hidden class=anchor aria-hidden=true href=#使用protobuf>#</a></h1><h2 id=编写go服务端>编写go服务端<a hidden class=anchor aria-hidden=true href=#编写go服务端>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// learnProto/server/server_main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bf</span> <span style=color:#e6db74>&#34;google.golang.org/protobuf/proto&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;learnProto/proto&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#e6db74>&#34;:8099&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Accept</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Received on connection.&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// read all from connection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>_data</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>_data</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Read error: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d bytes read\n&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Picture</span>{}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>bf</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>_data</span>, <span style=color:#a6e22e>message</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;data: %v&#34;</span>, <span style=color:#a6e22e>message</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>服务端的代码简单，我们定义一个TCP服务端，监听8099端口，从里面获取数据，通过proto将其转化成为对应的结构体。</p><p>由于是简单的使用proto，我们暂时不考虑里面传输的数据长度，直接构建一个1024长度的byte切片，从连接里面读取数据。然后使用 <code>bf.Unmarshal</code> 将里面的字节码数据反序列化为 <code>proto.Picture</code>结构体</p><p>后续可以优化这块，比如约定开始传送的是一个长度为 <code>HEADER_SIZE</code> 的数据，里面声明了我们本次传输的内容是图片还是视频，然后接下来的数据有多大，等。</p><h2 id=编写go客户端>编写go客户端<a hidden class=anchor aria-hidden=true href=#编写go客户端>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// learnProto/client/client_main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bf</span> <span style=color:#e6db74>&#34;google.golang.org/protobuf/proto&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;learnProto/proto&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#e6db74>&#34;localhost:8099&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Picture</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;pandas&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>Picture_JPG</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Data</span>: []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>msg</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bf</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>message</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Error write to connectin: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d bytes wrote.&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>客户端，我们使用 <code>net.Dial</code> 向服务端发起连接，然后构造一个假的 <code>Picture</code>消息，图片的名称为 <strong>pandas</strong>，图片的类型是 <strong>JPG</strong>，然后内容是随便给几个字节。</p><p>然后，使用 <code>bf.Marshal</code>，将结构体数据序列化成为字节 <code>[]byte</code>,通过tcp连接发送到客户端。</p><p>随后休眠一秒，防止连接提前终端而导致服务端数据读取失败。</p><h2 id=运行>运行<a hidden class=anchor aria-hidden=true href=#运行>#</a></h2><p>运行上述代码</p><p>客户端输出：</p><pre tabindex=0><code>2022/04/14 23:42:00 19 bytes wrote.
</code></pre><p>服务端输出：</p><pre tabindex=0><code>2022/04/14 23:42:00 Received on connection.
2022/04/14 23:42:00 19 bytes read
2022/04/14 23:42:00 data: name:&#34;pandas&#34;  type:JPG  data:&#34;\x01\x02\x03\x04\x05\x06\x07&#34;
</code></pre><p>可以看到，服务端收到了客户端发送的message，并且正确地将其序列化成为了 <code>proto.Picture</code>对象。</p><h2 id=改进>改进<a hidden class=anchor aria-hidden=true href=#改进>#</a></h2><h3 id=服务端可做改进>服务端可做改进：<a hidden class=anchor aria-hidden=true href=#服务端可做改进>#</a></h3><p>考虑新增消息类型的时候，可以通过使用约定 <strong>HEADER</strong> 的方式，来确定接下来发送的消息属于什么类型，以及消息的长度等。</p><p>接收到媒体信息的时候，将数据保存起来。</p><p>使用 goroutine改造，支持并发处理多个请求。</p><h3 id=客户端可做改进>客户端可做改进：<a hidden class=anchor aria-hidden=true href=#客户端可做改进>#</a></h3><p>图片的数据可以直接从文件或者数据库读取</p><p>自动解析图片的名称、格式等</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zihuanling.github.io/tags/go/>go</a></li><li><a href=https://zihuanling.github.io/tags/protobuf/>protobuf</a></li></ul><nav class=paginav><a class=prev href=https://zihuanling.github.io/posts/go-grpc-protobuf/><span class=title>« Prev Page</span><br><span>go: grpc和protobuf</span></a>
<a class=next href=https://zihuanling.github.io/posts/go-mongo/><span class=title>Next Page »</span><br><span>Go 使用mongodb</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on twitter" href="https://twitter.com/intent/tweet/?text=go%20%e5%92%8c%20protobuf&url=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f&hashtags=go%2cprotobuf"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f&title=go%20%e5%92%8c%20protobuf&summary=go%20%e5%92%8c%20protobuf&source=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f&title=go%20%e5%92%8c%20protobuf"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on whatsapp" href="https://api.whatsapp.com/send?text=go%20%e5%92%8c%20protobuf%20-%20https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share go 和 protobuf on telegram" href="https://telegram.me/share/url?text=go%20%e5%92%8c%20protobuf&url=https%3a%2f%2fzihuanling.github.io%2fposts%2fgo-proto%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://zihuanling.github.io/>Coding and Life</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>