<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Coding and Life</title><meta name=keywords content><meta name=description content="Posts - Coding and Life"><meta name=author content="LingZihuan"><link rel=canonical href=https://zihuanling.github.io/posts/><meta name=google-site-verification content="G-FEL07ZZK1M"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/favicon.ico as=image><link rel=icon href=https://zihuanling.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zihuanling.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://zihuanling.github.io/favicon.ico><link rel=apple-touch-icon href=https://zihuanling.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zihuanling.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://zihuanling.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?57e5cca974e7e653044600798423acf5",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-FEL07ZZK1M"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FEL07ZZK1M",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://zihuanling.github.io/posts/"><meta property="og:image" content="https://zihuanling.github.io/avatar.jpeg"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zihuanling.github.io/avatar.jpeg"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zihuanling.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zihuanling.github.io/ accesskey=h title="Coding and Life (Alt + H)"><img src=https://zihuanling.github.io/favicon.ico alt=logo aria-label=logo height=35>Coding and Life</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zihuanling.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://zihuanling.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zihuanling.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zihuanling.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zihuanling.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>go 和 protobuf</h2></header><section class=entry-content><p>Google protocol buffers 简称protobuf，它是谷歌提供的跨语言，跨平台的，可扩展的用来将结构化的数据进行序列化的一种机制。就像XML，但是更加精简、快速和简单。我们可以先预先定义我们的协议（写到一个 .proto 文件里面），里面声明了我们需要怎么去将数据结构化，然后，我们可以使用这份proto，去生成我们指定的语言源代码文件，我们就能够很方便地从各种数据流中读取结构化数据，或者是写入结构化数据。并且是跨语言的。
Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.
安装protoc编译器 ....</p></section><footer class=entry-footer><span title="2022-04-14 21:14:52 +0800 +0800">April 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;LingZihuan</footer><a class=entry-link aria-label="post link to go 和 protobuf" href=https://zihuanling.github.io/posts/go-proto/></a></article><article class=post-entry><header class=entry-header><h2>Go 使用mongodb</h2></header><section class=entry-content><p>安装 mkdir go-mongo go mod init go-mongo go get go.mongodb.org/mongo-driver/mongo 使用 数据库里面有一条这样的数据：
{ "_id": { "$oid": "6252912ec4495f97bccf41aa" }, "title": "My Mongo Post", "create_time": { "$date": "2022-04-10T10:33:45.149Z" }, "viewer": 201 } 连接数据库 // 关键代码 const MONGO_URI = "mongodb://localhost:27017/test" client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(MONGO_URI)) // 优雅关闭连接 defer client.Disconnect(context.TODO()) 数据查询 首先获取到对应的database以及collection
coll := client.Database("test").Collection("post") 然后查询：
coll := client.Database("test").Collection("post") var result bson.M // 需要一个bson.M 对象，用于存储查询回来的数据 // FindOne 接受2个参数，一个context，一个filter，filter 为 bson....</p></section><footer class=entry-footer><span title="2022-04-10 16:06:40 +0800 +0800">April 10, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;LingZihuan</footer><a class=entry-link aria-label="post link to Go 使用mongodb" href=https://zihuanling.github.io/posts/go-mongo/></a></article><article class=post-entry><header class=entry-header><h2>go：简简单单的并发网络连接</h2></header><section class=entry-content><p>go 是天生支持并发的，我们只要 使用 go func() 就可以快速实现并发。在网络服务的处理中，实现并发可以大大提高服务的吞吐量，我们来研究一下。
简单的TCP服务器 我们先来实现一个简单的tcp服务，监听8989端口，从连接中读取一段数据，这段数据表示的是当前请求的id，然后返回一段话。
服务器 server/main.go
package main import ( "fmt" "log" "net" ) func main() { // 启动tcp连接，监听8989端口 l, err := net.Listen("tcp", ":8989") if err != nil { log.Fatalf("Server listening error: %s\n", err) } for { conn, err := l.Accept() if err != nil { log.Printf("Accept error: %s\n", err) continue } // 接收连接,调用handleConn处理当前连接 handleConn(conn) } } func handleConn(conn net....</p></section><footer class=entry-footer><span title="2022-04-06 20:45:19 +0800 +0800">April 6, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;LingZihuan</footer><a class=entry-link aria-label="post link to go：简简单单的并发网络连接" href=https://zihuanling.github.io/posts/go-concurrent-server/></a></article><article class=post-entry><header class=entry-header><h2>Go：简单的跨平台rpc服务</h2></header><section class=entry-content><p>RPC RPC - Remote Procedure Call 称为远程过程调用，是分布式系统中，不同节点调用的方式（进程间通信），属于 C/S 模式。由客户端发起，调用服务端的方法进行通信，服务端将结果返回给客户端。
RPC的两个核心：
通信协议 序列化 序列化和反序列化是一种把传输内容编码和解码的方式，常见的编解码方式有 JSON、Protobuf 等。
大多数 RPC 架构中，都有 Client、Client Stub、Server、Server Stub这四个组件，Client 和 Server 通过 Socket 进行通信。
flowchart LR subgraph 服务端进程 s(Server) ss(Server Stub) s --调用--> ss ss --返回--> s end subgraph 客户端进程 c(Client) cs(Client Stub) c --调用--> cs cs --返回--> c end 客户端进程 ==网络消息==> 服务端进程 服务端进程 ==> 客户端进程 调用流程：
client 调用 client stub，同时把参数传给 client stub client stub将参数打包编码，然后通过系统调用发送到服务端进程 客户端本地系统发送信息到服务器 服务器系统将信息发送到 server stub server stub 将信息解码 server stub 调用真正的服务端程序 server server 处理后，通过同样的方式，将结果返回到 client go 实现简单的RPC服务 go内置了 net/rpc 包帮助我们实现rpc服务。...</p></section><footer class=entry-footer><span title="2022-03-30 10:52:00 +0800 +0800">March 30, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;LingZihuan</footer><a class=entry-link aria-label="post link to Go：简单的跨平台rpc服务" href=https://zihuanling.github.io/posts/go-rpc-server/></a></article><article class=post-entry><header class=entry-header><h2>Go：简单的http服务以及Restful Api</h2></header><section class=entry-content><p>简易 http 服务 使用 go 自带的 http 模块实现一个简单的 http 服务器，对请求者说一句 Hello, go http!
func main(){ http.HandleFunc("/hello", sayHello) http.ListenAndServe(":8080", nil) } func sayHello(resp http.ResponseWriter, req *http.Request) { log.Println("In say hello") resp.WriteHeader(http.StatusOK) resp.Write([]byte("Hello, go http!")) } 运行上述代码，在终端使用 curl 访问该地址，返回正常：
>curl http://localhost:8080/hello Hello, go http! 且程序使用 log 打印了一句： 2022/03/27 15:32:48 In say hello
但是，我们的http方法有很多， GET/POST/PUT/PATCH/DELETE 等，我们使用任意一个方法，访问上述地址，都能得到 Hello, go http! 这句返回，如 POST:
>curl -X POST http://localhost:8080/hello Hello, go http!...</p></section><footer class=entry-footer><span title="2022-03-27 15:27:00 +0800 +0800">March 27, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;LingZihuan</footer><a class=entry-link aria-label="post link to Go：简单的http服务以及Restful Api" href=https://zihuanling.github.io/posts/go-http-server/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zihuanling.github.io/posts/>« Prev Page</a>
<a class=next href=https://zihuanling.github.io/posts/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://zihuanling.github.io/>Coding and Life</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>