<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>daily on Coding and Life</title>
    <link>https://zihuanling.github.io/tags/daily/</link>
    <description>Recent content in daily on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 18 Apr 2022 00:05:28 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/tags/daily/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go: 读取文件</title>
      <link>https://zihuanling.github.io/posts/go-readfiles/</link>
      <pubDate>Mon, 18 Apr 2022 00:05:28 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-readfiles/</guid>
      <description>学习网站： https://gobyexample.com/reading-files
可以直接读取文件里面的所有内容到内存里面：
data, err := os.ReadFile(&amp;#34;/tmp/data&amp;#34;) fmt.Println(string(data)) 有时候想要自定义一些操作，比如读取文件里面的某些内容，从某个位置开始读取等，这时候，我们可以用 os.Open 打开一个文件，返回一个 os.File 对象。
f, err := os.Open(&amp;#34;/tmp/data&amp;#34;) 我们可以定义一个缓存（5个字节的[]byte类型），然后从文件中读取内容，读取的内容大小上限为5：
b1 := make([]byte, 5) n1, err := f.Read(b1) fmt.Printf(&amp;#34;%d bytes read from file: %s\n&amp;#34;, n1, string(b1)) 调用 f.Read来读取文件，返回两个结果，第一个为实际读取的内容长度，第二个为error。我们定义了一个长度为5的 b1 来存储文件内容，但是文件里面的内容长度可能只有3，因此，n1不一定等于5，它是实际读取的长度。
同样，我们还能用 os.Seek，来查找文件的位置，第一个参数为 offset，意味着偏移量，第二个参数为 whence，
 0表示从文件的开始位置进行偏移查找 1表示从文件的当前位置开始偏移，如果之前已经设置过偏移，再次设置则从当前位置开始偏移 2表示从文件的末尾开始偏移  o2, err := f.Seek(6, 0) b2 := make([]byte, 2) n2, err := f.Read(b2) fmt.Printf(&amp;#34;%d bytes read at %d\n&amp;#34;, n2, o2) fmt.Printf(&amp;#34;Value is : %s\n&amp;#34;, string(b2[:n2])) golang 的 io包提供了一些有用的函数，帮助我们高效读取。比如 io.</description>
    </item>
    
    <item>
      <title>让github page支持mermaid语法</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</guid>
      <description>目前，github page 会将 markdown里面的 mermaid 块渲染成为一个 div.language-mermaid 的 html 代码块，但是，mermaid-js仅支持渲染 div.mermaid 的html代码块，因此，我们需要做一点处理。
我们只需要在文章模板的末尾，添加如下转化代码即可：
文件：_layouts/post.html {%- if content contains &amp;#39;mermaid&amp;#39; -%} &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const config = {  startOnLoad:true,  theme: &amp;#39;forest&amp;#39;,  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll(&amp;#39;.language-mermaid&amp;#39;)); &amp;lt;/script&amp;gt; {% endif %} 上述代码手动将 div.language-mermaid 添加到 mermaid引擎的渲染中。
引用 在文章里面指定文章layout，即可引用，并且渲染mermaid！
--- layout: post --- 其他方法 当然也可以在 _config.yml 配置kramdown, 让其可以将 mermaid 块渲染成 div.mermaid 这样的html的代码块，但是实现起来有点复杂。
参考： Issue https://github.</description>
    </item>
    
    <item>
      <title>第一篇GitHub Page博客</title>
      <link>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</guid>
      <description>从 lemonchan.github.io fork了这个博客项目，感觉太棒了，设计很简洁，我需要的功能基本上都有。
感谢！</description>
    </item>
    
  </channel>
</rss>
