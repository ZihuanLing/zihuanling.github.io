<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Coding and Life</title>
    <link>https://zihuanling.github.io/</link>
    <description>Recent content on Coding and Life</description>
    <image>
      <url>https://zihuanling.github.io/avatar.jpeg</url>
      <link>https://zihuanling.github.io/avatar.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 26 Mar 2022 20:01:10 +0800</lastBuildDate><atom:link href="https://zihuanling.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>17.go: 代码检查和性能优化</title>
      <link>https://zihuanling.github.io/posts/go-17-quarlity-and-optimization/</link>
      <pubDate>Sat, 26 Mar 2022 20:01:10 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-17-quarlity-and-optimization/</guid>
      <description>对我们的代码进行检查，有助于提高代码质量，确保代码更加符合规范。
使用 golangci-lint 进行代码检查 go语言代码分析的工具有很多，如 golint、gofmt、misspell等，我们一般使用 集成工具 golangci-lint，而不是单独使用他们。
安装 go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.32.2 查看版本 golangci-lint version 输出：
golangci-lint has version v1.32.2 ... 运行检查： golangci-lint run quality/ 这里的 quality是一个包，里面有一个 main.go 文件，内容如下：
quality/main.go
package main  import &amp;#34;os&amp;#34;  func main(){ 	os.Mkdir(&amp;#34;/tmp&amp;#34;, 0666) } 运行检查后，输出如下：
quality\main.go:6:10: Error return value of `os.Mkdir` is not checked (errcheck) os.Mkdir(&amp;#34;/tmp&amp;#34;, 0666) 因为 os.Mkdir 返回一个 error，但是我们没有处理这个 error，因此提示了这个错误。
golangci-lint 配置 golangci-lint是一个集成工具，里面有很多linters，我们可以用 golangci-lint linters 查看有哪些linters，以及他们的作用、启用情况，默认启用的linters如下：
deadcode - 死代码检查 errcheck - 返回错误是否使用检查 gosimple - 检查代码是否可以简化 govet - 代码可疑检查，比如格式化字符串和类型不一致 ineffassign - 检查是否有未使用的代码 staticcheck - 静态分析检查 structcheck - 查找未使用的结构体字段 typecheck - 类型检查 unused - 未使用代码检查 varcheck - 未使用的全局变量和常量检查 我们可以通过一个 .</description>
    </item>
    
    <item>
      <title>16.go: 单元测试和基准测试</title>
      <link>https://zihuanling.github.io/posts/go-16-test-1/</link>
      <pubDate>Mon, 21 Mar 2022 22:23:25 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-16-test-1/</guid>
      <description>单元测试 单元测试就是对单元进行测试（听起来是一句废话），单元可以是一个函数、一个模块等，我们最小的单元是一个函数。
以斐波那契数列为例，实现一个测试用例
test/main.go
package main  // 斐波那契数列 func Fibonacci(n int) int { 	if n &amp;lt;= 0 { 	return 0 	} else if n == 1 { 	return 1 	} 	return Fibonacci(n-1) + Fibonacci(n-2) } 我们在 main.go 里面写了一个 Fibonacci函数，用于计算对应的斐波那契值。
我们接下来写一个测试用例，测试的文件名应该是以 _test.go 结尾的，前面的名称最好是需要测试的文件名称，比如要测试 main.go，则测试文件命名为 main_test.go，而在 测试文件里面，需要一个以 Test开头的函数，后面接需要测试的函数名称，如 TestFibonacci，这个函数接受一个 *Testing.T指针，且不返回任何值
test/main_test.go
func TestFibonacci(t *testing.T) { 	result := map[int]int{ 	1: 1, 2: 1, 3: 2, 4: 3, 5: 5, 	6: 8, 7: 13, 8: 21, 	} 	for n, expect := range result { 	got := Fibonacci(n) 	if expect !</description>
    </item>
    
    <item>
      <title>15.go深入：SliceHeader，高效的slice</title>
      <link>https://zihuanling.github.io/posts/go-15-depth-slice-header/</link>
      <pubDate>Fri, 18 Mar 2022 14:34:12 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-15-depth-slice-header/</guid>
      <description>数组 数组由两部分组成：数组的大小和数组内部的元素类型。
// 伪代码表示 array {  len  item type } 看以下两个数组的定义：
a1 := [1]string{&amp;#34;mike&amp;#34;} a2 := [2]string{&amp;#34;mike&amp;#34;} 上述定义的两个变量，a1的类型为 [1]string，a2的类型为 [2]string，所以说，数组的大小也属于数组类型的一部分。
数组的两个限制   **一旦一个数组被声明，它的大小和内部的类型就不能改变，**我们将不能随意向其中追加任意多的元素。
  另外，当我们使用数组存储大量数据，然后将数组作为函数的参数进行传值时，由于函数之间是值传递的，因此，数组的拷贝将会耗费巨大的内存。
  slice 切片 我们可以将切片理解为动态的数组。
切片是对数组的封装，它的底层是一个数组存储了所有的元素，但是它可以动态地添加元素，容量不足时可以自动扩容。
动态扩容 使用内置的append方法，向切片中追加元素，返回一个新的切片。
同时，当容量不足的时候，append会自动对切片进行扩容。
func main(){  ss := []string{&amp;#34;mike&amp;#34;} // 定义切片ss  fmt.Printf(&amp;#34;slice before append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss))  ss = append(ss, &amp;#34;lucy&amp;#34;, &amp;#34;john&amp;#34;) // append 追加元素  fmt.Printf(&amp;#34;slice after append: %s, length=%d, cap=%d\n&amp;#34;, ss, len(ss), cap(ss)) } 输出：</description>
    </item>
    
    <item>
      <title>14.go深入：非类型安全unsafe</title>
      <link>https://zihuanling.github.io/posts/go-14-depth-unsafe/</link>
      <pubDate>Tue, 15 Mar 2022 22:26:20 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-14-depth-unsafe/</guid>
      <description>unsafe是不安全的，可以绕过go的安全检查机制，直接对内存进行读写，非必要不使用。
指针类型转换 go是一门强类型的静态语言，意味着一旦定义了，类型就不能改变，且类型检查在运行前已经完成。
出于安全考虑，go不允许两个指针类型进行转换，比如 *int 不能转换成 *float。
i := 10 ip := &amp;amp;i var fp *float64 = (*float64)(ip)	// 尝试将 *int 转换成 *float64 在编译的时候，会报错： cannot convert ip (type * int) to type * float64，提示不可转换
unsafe.Pointer unsafe.Pointer表示任意类型的指针，上述例子中，我们使用 unsafe.Pointer进行中转，实现指针类型转换
i := 10 ip := &amp;amp;i var fp *float64 = (*float64)(unsafe.Pointer(ip))	// 尝试将 *int 转换成 *float64 *fp = *fp * 3 fmt.Println(i,*fp, ip, fp) 输出：
30 1.5e-322 0xc0000aa058 0xc0000aa058 可以看到，通过转化后的指针修改指向内存的值，原始值i也变成了30，ip和fp指向的是同一块内存地址。需要注意的是，试图通过 *fp 打印出原来内存的数据时，却出现了一个异常值，说明指针可以通过 unsafe.Pointer 进行转化，但转化后的指针不一定可以访问到原始内存的值。</description>
    </item>
    
    <item>
      <title>13.go深入：reflect 运行时反射</title>
      <link>https://zihuanling.github.io/posts/go-13-depth-reflect/</link>
      <pubDate>Mon, 14 Mar 2022 00:33:13 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-13-depth-reflect/</guid>
      <description>啥是反射 go语言中，反射为我们提供了一种可以在运行时操作任意类型对象的能力，比如，查看一个接口变量的具体类型、看一个结构体有多少字段、修改某个字段的值等。
比如 fmt.Println：
func Println(a ...interface{}) (n int, err error) {  return Fprintln(os.Stdout, a...) } 函数定义中有一个可变参数 a ...interface{}，我们在调用的时候，可以传1个到多个参数进去。
reflect.Value 和 reflect.Type go语言的反射定义中，任何接口都有两个部分组成：接口的具体类型，以及具体类型对应的值。如 var i in = 3，由于 interface{}可以表示任何类型，因此i可以转化为 interface{}，将其当做一个接口，此时它在go反射中就表示成 &amp;lt;Value, Type&amp;gt;，其中Value为3，Type为int。
go反射中，标准库为我们提供了两种类型 reflect.Value和 reflect.Type分别表示变量的值和类型，并且可以用函数 reflect.ValueOf和 reflect.TypeOf分别获取任意对象 Value和Type。
func main(){  var i int = 3  iv := reflect.ValueOf(i)  it := reflect.TypeOf(i)  fmt.Println(iv, it) } reflect.Value 结构体定义 reflect.Value 可以通过 reflect.ValueOf获得，其结构体定义如下
type Value struct {  typ *rtype  ptr unsafe.</description>
    </item>
    
    <item>
      <title>12.go深入：new、make和内存分配</title>
      <link>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</link>
      <pubDate>Sun, 13 Mar 2022 23:35:38 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-12-depth-new-and-make/</guid>
      <description>Go语言程序所管理的虚拟内存空间会被分为两部分：堆内存和栈内存。栈内存主要由Go语言来管理，开发者无法干涉太多，堆内存则有开发者进行分配。
变量 一个数据类型，在声明之后，会被赋值给一个变量，变量存储了程序所需的数据。
变量的声明 单纯的声明变量，可以使用var关键字，如：
var s string	// 声明一个[字符串]变量，初始值为零值&amp;#34;&amp;#34; var sp *string	// 声明一个[字符串指针]变量，初始值为 nil 变量的初始化 有3种方法
 声明的时候直接初始化： var name string = &amp;quot;mike&amp;quot; 声明之后再进行赋值初始化： name = &amp;quot;mike&amp;quot;,此前 name 变量已经声明 直接使用 := 进行初始化： name := &amp;quot;mike&amp;quot;  值变量和指针变量初始化的区别 我们使用值初始化的时候，可以简单的这样写：
var name string name = &amp;#34;mike&amp;#34; 但是，当我们使用指针初始化的时候：
var nameP *string // 声明一个字符串指针 *nameP = &amp;#34;mike&amp;#34;	// 给nameP指向的地址赋值初始化 这时候，由于 nameP 指向的是一个空地址 nil，我们对这个空地址进行赋值初始化的时候，会报以下错误：
panic: runtime error: invalid memory address or nil pointer dereference 显而易见，我们无法对一个空地址赋值。</description>
    </item>
    
    <item>
      <title>11. go深入：值、指针以及引用类型</title>
      <link>https://zihuanling.github.io/posts/go-11-depth/</link>
      <pubDate>Thu, 10 Mar 2022 14:44:08 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/go-11-depth/</guid>
      <description>值类型 假设我们有一个这样的结构体：
type person struct {  name string  age uint } 然后我们试图定义一个函数，修改这个结构体实例的值：
func modify(argP person){  argP.name = &amp;#34;Nobody&amp;#34;  argP.age = 10 }  // 我们实际运行一下这个函数 func main(){  p := person{name: &amp;#34;mike&amp;#34;, age: 19}  fmt.Println(p)  modify(p)  fmt.Println(p) } 上述的例子中，我们期望在经过了modify函数修改后，打印出来的结果是 {Nobody, 10}，然而实际上，输出的仍然是初始化的值： {mike, 19}
为啥会这样呢，因为上面定义的变量 p 是值类型，而通过modify函数传入的变量值argP只是原始值变量p的一份值拷贝，而不是原来的数据本身。
其实，我们只要在modify函数内部和外部打印出变量p和argP的地址，就可以发现他们的不同之处。
func modify(argP person){  fmt.Printf(&amp;#34;address of arg p: %p\n&amp;#34;, &amp;amp;argP)  // ... }  func main(){  // .</description>
    </item>
    
    <item>
      <title>让Hugo Papermod主题支持 Mermaid</title>
      <link>https://zihuanling.github.io/posts/hugo-papermod-mermaid/</link>
      <pubDate>Thu, 10 Mar 2022 09:40:06 +0800</pubDate>
      
      <guid>https://zihuanling.github.io/posts/hugo-papermod-mermaid/</guid>
      <description>由于我的博客文章里面用到了mermaid绘制流程图，从Jekyll迁移到Hugo之后，使用的PaperMod主题是默认不支持mermaid渲染的，搜了很多帖子，看到有很多解决办法。
比如有定义 /layouts/shortcodes/mermaid.html 的，然后在代码里面，需要用到mermaid的地方（文章里面）这样写：
{{ &amp;lt;mermaid&amp;gt; }} ... 这里写mermaid内容 {{ &amp;lt;/mermaid&amp;gt; }} 但是这样的写法不是我想要的，我想要的是保留原来的写法，能够在渲染成html的时候，动态渲染 .language-mermaid 这个类的元素为 mermaid代码块。
查了一下PaperMod这个主题的代码，发现预留了 extend_head.html 这个扩展html头，太棒了！我们就可以在不改变原有主题代码的情况下，增添自己的head内容！
首先，我们新建一个文件： layouts/partials/extend_head.html，然后在里面写上mermaid的初始化代码：
&amp;lt;!-- 使用cdn加载文件 --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; // 自定义mermaid配置 const config = {  startOnLoad:true,  theme: &amp;#39;forest&amp;#39;,  themeVariables: {  lineColor: &amp;#34;#fafafa&amp;#34; // 由于paperMod的代码块背景是黑色的，这里将线条设置为白色  },  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); // 需要注意的是，要将初始化代码放到 window.onload 回调函数里面才有用 // 否则会因为在html元素加载前进行初始化，找不到元素而失效 window.onload = () =&amp;gt; {  window.</description>
    </item>
    
    <item>
      <title>Jinja2: 判断变量是否为空、存在等</title>
      <link>https://zihuanling.github.io/posts/2022-03-09-jinja-templates-variable-judgement/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-09-jinja-templates-variable-judgement/</guid>
      <description>在 Jinja2 模板中，我们经常需要判断一个变量是否存在，里面的值是否为空等等。
检查变量是否存在，或者是否被定义 {% if variable is defined %}  variable is defined {% else %}  variable is not defined {% endif %} 检查数据的长度是否为空 对于列表类型的变量，我们可能需要知道这个列表是否为空的
{% if variable | length %}  variable is not empty {% else %}  variable is empty {% endif %} 需要注意的是，如果这个变量为非列表类型，模板渲染的时候会报错
检查变量值是否为True {% if variable is sameas true %}  variable is true {% else %}  variable is not true {% endif %} 同样，我们也可以用关键字and来实现多个判断 判断变量存在且不为空（列表型变量） {% if variable is defined and variable | length %}  variable is defined and is not empty {% else %}  variable is not defined or empty {% endif %} 判断变量存在且为true（布尔型变量） {% if variable is defined and is sameas true %}  variable is defined and is true {% else %}  variable is not defined or not true {% endif %} </description>
    </item>
    
    <item>
      <title>10. go深入：Go 中的指针</title>
      <link>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-06-go-10-depth/</guid>
      <description>什么是指针 可以简单将指针理解为内存地址。
指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象，可以是整型、字符串、或者是我们自定义的任意结构体类型。
也可以理解为：指针就是一本书上的目录上面的页码，这个页码指向具体的内容。
指针的声明和定义 以字符串指针为例
// 声明一个字符串指针变量 var sp *string // 直接通过 &amp;amp; 操作符获取一个字符串的地址 s := &amp;#34;Hello world.&amp;#34; sp := &amp;amp;s // 还可以使用 new 函数，传入一个类型作为参数，用以返回该类型的指针 sp := new(string) 指针的操作 针对指针的操作，有两种：获取或者修改指针指向的值
 获取指针指向的值  使用 *指针变量 获取指针指向的值，如 *sp 获取sp指针指向的内存地址的值。
修改指针指向的值  修改跟获取值也是类似的，使用 *指针变量 = 值 来修改，如 *sp = &amp;quot;new value&amp;quot;，这样，就把 sp指针指向的内存地址值修改为了 new value
注意 另外，通过 var sp *string 定义的sp指针，初始值是nil，表示它没有指向任何一块内存地址，我们不能够对它进行取值和赋值操作，否则，会提示：
invalid memory address or nil pointer dereference
要解决这个问题，只需要使用 new 函数给该地址分配一块内存即可：
var sp *string = new(string)</description>
    </item>
    
    <item>
      <title>9. go并发：Go 中的并发模式</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-go-9-concurrency/</guid>
      <description>for select 模式 这是一种常见的并发模式，我们一般使用 for {}  死循环，然后里面加select配合channel，获取协程的终止信号，来控制协程的退出
for {  select {  case &amp;lt;- done:  // received stop signal, stopping.  return  default: 	// processing ...  } } 类似的还有 for range select模式，主要就是使用 for ... range 遍历某个数据数组，将数据发送到channel里面：
for _, value := range []int{} {  select {  case &amp;lt;- done:  // 接受到终止信号  return  case resultCh &amp;lt;- value:  // do nothing but put value to rsult channel  } } select timeout 模式 select timeout模式，核心在于使用 time.</description>
    </item>
    
    <item>
      <title>让github page支持mermaid语法</title>
      <link>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-03-04-support-mermaid-on-github-page/</guid>
      <description>目前，github page 会将 markdown里面的 mermaid 块渲染成为一个 div.language-mermaid 的 html 代码块，但是，mermaid-js仅支持渲染 div.mermaid 的html代码块，因此，我们需要做一点处理。
我们只需要在文章模板的末尾，添加如下转化代码即可：
文件：_layouts/post.html {%- if content contains &amp;#39;mermaid&amp;#39; -%} &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const config = {  startOnLoad:true,  theme: &amp;#39;forest&amp;#39;,  flowchart: {  useMaxWidth:false,  htmlLabels:true  } }; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll(&amp;#39;.language-mermaid&amp;#39;)); &amp;lt;/script&amp;gt; {% endif %} 上述代码手动将 div.language-mermaid 添加到 mermaid引擎的渲染中。
引用 在文章里面指定文章layout，即可引用，并且渲染mermaid！
--- layout: post --- 其他方法 当然也可以在 _config.yml 配置kramdown, 让其可以将 mermaid 块渲染成 div.mermaid 这样的html的代码块，但是实现起来有点复杂。
参考： Issue https://github.</description>
    </item>
    
    <item>
      <title>8. go并发：Context-多线程并发控制神器</title>
      <link>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-27-go-8-concurrency/</guid>
      <description>协程如何退出 一般来说，我们执行协程，需要等到协程执行完毕，才能够退出。但是，当我们想要让协程提前退出，就需要一种机制，去控制协程的退出。
以下例子使用select + channel的方式，控制协程的退出
 func main() { 	ch := make(chan bool) 	var wg sync.WaitGroup 	go func() { 	defer wg.Done()  // 开启looper协程 	looper(ch) 	}() 	wg.Add(1)  // 5秒后发送中断信号 	time.Sleep(time.Second * 5) 	fmt.Println(&amp;#34;Signal to goroutine exit...&amp;#34;) 	ch &amp;lt;- true 	fmt.Println(&amp;#34;Signal sent.&amp;#34;) 	wg.Wait() // 等待协程完全退出 	fmt.Println(&amp;#34;Exit.&amp;#34;) }  func looper(ch &amp;lt;-chan bool){ 	for { 	select { 	case &amp;lt;-ch: 	fmt.</description>
    </item>
    
    <item>
      <title>使用 getopts 获取命令行中的参数</title>
      <link>https://zihuanling.github.io/posts/2022-02-24-try-linux-getopts/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-24-try-linux-getopts/</guid>
      <description>在某些场景中，我们写的bash脚本需要获取命令行中指定的某些参数，用以判断某些条件，或者设置某些变量等。
getopts可以让我们通过指定 -a 1 的方式指定对应的参数名称和参数值。
一个更详细的小教程，可以看这里： getopts_tutorial 使用 可以使用 while getopts &amp;quot;:a:p:&amp;quot; opt; do... 的方式，将参数名称读取到 opt 变量中，然后，在循环体中，使用 $OPTARG 获取到具体的参数值。
一个小栗子，用于快捷创建新的 gihub pages 博客模板：
#!/usr/bin/env bash  # 用于快捷创建新博客 # 命令： ./new.sh -t 标签1,标签2 -n 文章标题 -l layout -c 1  layout=&amp;#34;post&amp;#34; title=&amp;#34;new-post&amp;#34; now=$(date +%Y-%m-%d) can_comment=&amp;#34;false&amp;#34; author=&amp;#34;ZihuanLing&amp;#34;  while getopts &amp;#34;:l:t:c:n:&amp;#34; opt; do  case $opt in  l)  layout=&amp;#34;$OPTARG&amp;#34;  ;;  t)  tags=&amp;#34;[$OPTARG]&amp;#34;  ;;  c)  can_comment=&amp;#34;true&amp;#34;  ;;  n)  title=$(echo &amp;#34;$OPTARG&amp;#34; | sed &amp;#34;s/ /\-/g&amp;#34;)  ;;  \?</description>
    </item>
    
    <item>
      <title>第一篇GitHub Page博客</title>
      <link>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-23-first-github-page-blog/</guid>
      <description>从 lemonchan.github.io fork了这个博客项目，感觉太棒了，设计很简洁，我需要的功能基本上都有。
感谢！</description>
    </item>
    
    <item>
      <title>7. go并发：同步原语，用sync包控制并发</title>
      <link>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-19-go-7-concurrency/</guid>
      <description>go在并发的时候，可能会出现多个协程同时访问一个资源的时候，这就出现了资源竞争。也可能出现协程还在运行，但是主程序却退出了的情况，这是缺少控制导致的。
用sync包，可以方便的控制资源的访问，也可以方便实现阻塞等待，让协程执行完毕再退出程序，或者执行下一步。
资源竞争 在同一个goroutine中，如果分配的内存没有被其他的goroutine访问，只在该goroutine中使用，则不存在资源竞争问题
如果同一块内存被多个goroutine同时访问，就会产生不知道谁先访问，也无法预料最后结果的情况，这就是资源竞争：
// 共享的资源 var sum = 0 func main(){  for i := 0; i &amp;lt; 100; i++ {  go add(10)  }  // goroutine 不会阻塞下面的代码，此处Sleep一下，防止main goroutine直接退出  // 而导致未完成的goroutine也被终止  time.Sleep(time.Second * 2)  fmt.Println(&amp;#34;Sum is:&amp;#34;, sum) }  func add(i int) {  sum += i } 上述例子中，sum变量为共享的资源，程序运行的过程中会发生资源竞争。
 使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go 语言代码是否存在资源竞争
 同步原语 sync.</description>
    </item>
    
    <item>
      <title>6. go并发：Goroutines和Channels的声明和使用</title>
      <link>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-18-go-6-concurrency/</guid>
      <description>并发，就是让程序在同一时刻做多件事情。
go语言天生自带并发属性，使得并发编程十！分！方！便！，我们只需要 go 函数名() 即可！\(^o^)/
进程和线程 进程 程序启动时，系统会为其创建一个进程
线程 是进程的执行空间，一个进程可以包含多个线程，线程被操作系统调度执行 一个程序启动，对应的进程会被创建，同时也会创建一个线程（主线程），主线程结束，整个程序也就退出了。 我们可以从主线程创建其他的子线程，这就是多线程并发
协程 Goroutine goroutine比线程更加轻盈，被Go runtime调度。 启动协程： go function()
// 这里启动了两个goroutine， 一个是用go关键字触发的，另一个是 main goroutine（主线程） func main(){  go fmt.Println(&amp;#34;Hello goroutine.&amp;#34;)  fmt.Println(&amp;#34;Main goroutine.&amp;#34;)  time.Sleep(time.Second) } Channel 多个goroutine之间，使用 channel进行通信
声明一个channel // 直接使用 make 创建一个channel，接受的数据类型是string ch := make(chan string) // 一个channel的操作只有两种： // - 发送，向chan中发送值： chan&amp;lt;- // - 接受，从chan中获取值： &amp;lt;-chan demo
func main(){  ch := make(chan string)  go func(){  fmt.</description>
    </item>
    
    <item>
      <title>5. go基础：通过 error/deffer/panic 处理错误</title>
      <link>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-17-go-5-basic/</guid>
      <description>正确处理错误，可以让程序更加稳定。error是一个错误接口，一般来说，error是不会影响到整个程序运行的，我们可以自行处理。 而panic是会导致程序直接崩溃退出的，我们也可以用 go自带的recover()来恢复panic，在程序崩溃前进行资源的释放工作。
错误 error接口 error接口只有一个Error方法，返回具体的错误信息（string）
type error interface {  Error() string } 一个字符串转整数的例子：
func main(){  // try to conver alpha &amp;#34;a&amp;#34; to integer  i, err := strconv.Atoi(&amp;#34;a&amp;#34;)  if err != nil {  fmt.Println(err)  } else {  fmt.Println(i)  } } 尝试将字符 a 转换成为 整数，显然是不成功的，因此返回了err
 一般而言，error 接口用于当方法或者函数执行遇到错误时进行返回，而且是第二个返回值。通过这种方式，可以让调用者自己根据错误信息决定如何进行下一步处理。
 error 工厂函数 除了可以使用其他函数，自己定义的函数也可以返回错误信息给调用者
自定义error 自定义error就是先自定义一个新的类型，然后实现error接口
// 自定义一个结构体，携带错误码和具体的错误信息 type commonError struct {  errorCode int	// 错误码  errorMsg string // 错误信息 }  // 实现error接口 func (ce *commonError) Error() string {  return ce.</description>
    </item>
    
    <item>
      <title>3. go基础：函数和方法</title>
      <link>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-15-go-3-basic/</guid>
      <description>函数和方法，大大提高了我们的代码复用率，也提高了代码的可读性。 go语言的函数和方法的定义十分简单，直接使用 func 关键字即可。
不同于python、C++等有类的概念，而这些类中，又有自己的方法，或者父类的方法。go语言中，我们可以定义一个数据结构，然后给这个数据结构实现自己的方法，同样可以实现【类】的效果，通过组合，同一个结构体中，也可以使用或者覆写其他结构体的方法。
函数 函数的组成：  关键字 func 函数名 funcName 参数 params 返回值（返回值类型） 函数体  func funcName(params) result { 	// body } // 示例1：普通的函数定义 func sum(a int, b int) int { 	return a + b } // 示例2：参数表的类型合并，(a int, b int) -&amp;gt; (a, b int) func sum2(a, b int) int { 	return a + b } // 示例3：多值返回，用 （） 包裹起来 func sum3(a, b int) (int, error) { 	if a &amp;lt; 0 || b &amp;lt; 0 { 	return 0, errors.</description>
    </item>
    
    <item>
      <title>4. go基础：结构体和接口</title>
      <link>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-16-go-4-basic/</guid>
      <description>接口是一种聚合类型，结构体是和调用方的一种约定，有点抽象类的意思。:)
结构体 结构体定义 结构体是一种聚合类型，里面可以包含任意类型的值，这些值就是我们定义的结构体成员，也称为字段
在go语言中，要定义一个结构体，需要使用 type+struct 关键字组合。
// 定义一个代表【人】的结构体 type person struct {  name string	// 名称  age uint	// 年龄 } 结构体的成员字段并不是必需的，也可以一个字段都没有，这种结构体成为空结构体。
type s struct {} 结构体声明使用 // 使用var声明一个person变量，未初始化，里面的值为各自变量的零值 var p person // 可以使用结构体字面量初始化的方式 p2 := person{&amp;#34;Mike&amp;#34;, 10} // 第一个值为 name，第二个值为age，与结构体字段定义顺序有关 // 可以指定字段名初始化，不按定义顺序 p3 := person{age: 10, name: &amp;#34;Mike&amp;#34;} 字段结构体 type address struct {  province string  city string } // 结构体的字段可以是任意类型，也可以是自定义的结构体 type person struct {  name string  age uint  addr address }  // 初始化 p := person{  name: &amp;#34;Mike&amp;#34;,  age: 10,  addr: address{  province: &amp;#34;Guandong&amp;#34;,  city: &amp;#34;Maoming&amp;#34;,  }, } fmt.</description>
    </item>
    
    <item>
      <title>2. go基础：使用array/slice/map</title>
      <link>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-02-10-go-2-basic/</guid>
      <description>数组，大概是每个变成语言都有基础数据结构。
Go的切片类型（slice）提供了一种方便和有效的方法来处理类型化数据序列（数组）。slice类似于其他语言中的数组，但有一些不同寻常的属性。
map可以理解为一个字典。
数组声明 可以使用 [长度]类型{} 来定义，比如 [2]string{}定义一个长度为2的字符串数组
这里的长度必须是一个常量，如果要使用变量去动态生成数组的话，需要使用make，如
make([]string, size) 这里的size是一个变变量，生成size长度的字符串数组
另外需要注意的是, [1]string 和 [2]string 不是用一种类型，长度也是数组类型的一部分
定义数组时可以省略数组的长度，此时会根据大括号{}里面的元素个数推到出数组的长度：
arr := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;} 这里会自动生成长度为5的字符串数组，适用于所有元素都被初始化的数据
但是如果只有特定元素被初始化的数组，就不合适了：
arr := [5]string{1: &amp;#34;a&amp;#34;, 3: &amp;#34;c&amp;#34;} 上述表示数组初始化索引为1的值为a，索引为3的值为c，其他未初始化的为空值（字符串的空值为&amp;quot;&amp;quot;）
如果我们不指定 [5]string，那么go就会根据我们定义的最大索引值3 来确定数组的长度为4
数组循环  使用传统的数组循环：  for i := 0; i &amp;lt; len(arr); i++ { 	fmt.Println(arr[i]) }  使用 for range 数组遍历，写法更加简洁  for index, value := range arr { 	fmt.Printf(&amp;#34;index = %v, value = %v\n&amp;#34;, index, value) } 切片 Slice 切片的区间是左闭右开，如arr[2:5]，选取的索引取数是[2,3,4] 切片的底层是（原）数组，将切片内容修改之后，原数组也会改变</description>
    </item>
    
    <item>
      <title>1. go基础：数据类型，以及控制结构</title>
      <link>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zihuanling.github.io/posts/2022-01-07-go-1-basic/</guid>
      <description>go最近很火啊，自带高并发，内置网络模块强大，作为后端工程师一枚，自然也要学起来！
go 的基础部分跟我们之前学过的大部分语言是都是十分相似的，上手十分简单。
第一个go程序 第一个程序大都是hello嘛，向新世界打个招呼 :)
import fmt  func main(){  fmt.Println(&amp;#34;hello golang!&amp;#34;) } 数据类型以及变量声明的方式 变量声明的方式 // var 变量名 类型 = 表达式 var num int = 1 // 也可以声明变量，但是不赋值 var num int	// 这样的默认值就是int的默认值 0 // 可以直接赋值并且声明类型 num := 1 // 可以实现多值定义 a, b, c := 1, 2, &amp;#34;hello&amp;#34; var (  a = 1  b = 2  c = &amp;#34;hello&amp;#34; ) 常量声明 常量声明，我们可以直接使用 const 关键字，不需要指定数据的类型，通常，常量我们用大写进行命名
我们指定变量的值，会自定将变量转为对应的类型</description>
    </item>
    
    
    
  </channel>
</rss>
